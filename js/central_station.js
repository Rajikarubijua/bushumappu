// Generated by CoffeeScript 1.6.2
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  define(['utils', 'graph'], function(utils, _arg) {
    var CentralStationEmbedder, Graph, Node, P, log2, radius, someAngle;

    Graph = _arg.Graph, Node = _arg.Node;
    P = utils.P;
    CentralStationEmbedder = (function() {
      /*
      		Lines get arranged star-like around the central node.
      		Each line has a star point.
      		
      		Lines have three kinds of nodes: hi, lo and other.
      		Lo nodes are nodes with degree one and are on the star point.
      		Hi nodes are nodes with degree bigger one and are on the star point.
      		Other nodes are nodes with degree bigger one and are on another star
      		point.
      		
      		On which star point get nodes with degree bigger one?
      		This is based on a balancing process. Each star point gets so many
      		hi nodes such that it is balanced with each other star point as good as
      		it gets.
      */
      function CentralStationEmbedder(config) {
        this.config = config;
      }

      CentralStationEmbedder.prototype.graph = function(central_kanji, all_radicals, all_kanjis) {
        var a, angle, b, central_node, hi_nodes, i, kanji, kanjiDegree, kanjiIsRelated, kanjiNode, kanjiRelevantRadicals, kanji_offset, line, line_i, lines, memo, n, node, node_i, node_r, nodes, r, radical, radical_node, related_kanjis, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _m, _n, _o, _p, _q, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

        lines = {};
        _ref = central_kanji.radicals;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          radical = _ref[_i];
          lines[radical.radical] = {
            radical: radical,
            hi: [],
            lo: [],
            other: []
          };
        }
        related_kanjis = utils.arrayUnique(d3.merge((function() {
          var _j, _len1, _ref1, _results;

          _ref1 = central_kanji.radicals;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            radical = _ref1[_j];
            _results.push(radical.jouyou);
          }
          return _results;
        })()));
        i = related_kanjis.indexOf(central_kanji);
        [].splice.apply(related_kanjis, [i, i - i + 1].concat(_ref1 = [])), _ref1;
        memo = new utils.Memo;
        kanjiIsRelated = memo.onceObj(function(kanji) {
          return __indexOf.call(related_kanjis, kanji) >= 0;
        });
        kanjiRelevantRadicals = memo.onceObj(function(kanji) {
          var _j, _len1, _ref2, _results;

          _ref2 = kanji.radicals;
          _results = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            radical = _ref2[_j];
            if (__indexOf.call(central_kanji.radicals, radical) >= 0) {
              _results.push(radical);
            }
          }
          return _results;
        });
        kanjiDegree = memo.onceObj(function(kanji) {
          return kanjiRelevantRadicals(kanji).length;
        });
        kanjiNode = memo.onceObj(function(kanji) {
          return new Node({
            data: kanji
          });
        });
        hi_nodes = [];
        for (_j = 0, _len1 = related_kanjis.length; _j < _len1; _j++) {
          kanji = related_kanjis[_j];
          node = kanjiNode(kanji);
          if (kanjiDegree(kanji) === 1) {
            node.style.lo = true;
            radical = kanjiRelevantRadicals(kanji)[0];
            lines[radical.radical].lo.push(node);
          } else {
            node.style.hi = true;
            hi_nodes.push(node);
          }
        }
        lines = d3.values(lines);
        for (_k = 0, _len2 = hi_nodes.length; _k < _len2; _k++) {
          node = hi_nodes[_k];
          for (_l = 0, _len3 = lines.length; _l < _len3; _l++) {
            line = lines[_l];
            if (_ref2 = line.radical, __indexOf.call(kanjiRelevantRadicals(node.data), _ref2) >= 0) {
              line.hi.push(node);
              break;
            }
          }
        }
        for (_m = 0, _len4 = lines.length; _m < _len4; _m++) {
          a = lines[_m];
          for (_n = 0, _len5 = lines.length; _n < _len5; _n++) {
            b = lines[_n];
            if (a === b) {
              continue;
            }
            node_i = -1;
            while (++node_i < a.hi.length) {
              if (b.hi.length >= a.hi.length) {
                break;
              }
              node = a.hi[node_i];
              if (_ref3 = b.radical, __indexOf.call(node.data.radicals, _ref3) < 0) {
                continue;
              }
              b.hi.push(node);
              [].splice.apply(a.hi, [node_i, node_i - node_i + 1].concat(_ref4 = [])), _ref4;
              --node_i;
            }
          }
        }
        for (_o = 0, _len6 = lines.length; _o < _len6; _o++) {
          a = lines[_o];
          for (_p = 0, _len7 = lines.length; _p < _len7; _p++) {
            b = lines[_p];
            if (a === b) {
              continue;
            }
            _ref5 = b.hi;
            for (_q = 0, _len8 = _ref5.length; _q < _len8; _q++) {
              node = _ref5[_q];
              if (_ref6 = a.radical, __indexOf.call(node.data.radicals, _ref6) >= 0) {
                a.other.push(node);
              }
            }
          }
        }
        node_r = my.config.gridSpacing;
        kanji_offset = config.kanjiOffset;
        central_node = kanjiNode(central_kanji);
        central_node.kind = 'central_node';
        n = central_kanji.radicals.length;
        lines = (function() {
          var _len10, _len11, _len12, _len9, _r, _ref7, _ref8, _ref9, _results, _s, _t, _u;

          _results = [];
          for (line_i = _r = 0, _len9 = lines.length; _r < _len9; line_i = ++_r) {
            line = lines[line_i];
            angle = someAngle(line_i);
            r = line.hi.length + line.lo.length + kanji_offset;
            r *= radius(node_r, angle);
            x = r * Math.cos(angle);
            y = r * Math.sin(angle);
            radical_node = new Node({
              x: x,
              y: y,
              data: line.radical
            });
            radical_node.kind = 'radical_node';
            _ref7 = __slice.call(line.hi).concat(__slice.call(line.lo));
            for (node_i = _s = 0, _len10 = _ref7.length; _s < _len10; node_i = ++_s) {
              node = _ref7[node_i];
              r = node_i + kanji_offset;
              r *= radius(node_r, angle);
              node.x = r * Math.cos(angle);
              node.y = r * Math.sin(angle);
            }
            _ref8 = line.hi;
            for (_t = 0, _len11 = _ref8.length; _t < _len11; _t++) {
              n = _ref8[_t];
              n.kind = 'hi_node';
            }
            _ref9 = line.lo;
            for (_u = 0, _len12 = _ref9.length; _u < _len12; _u++) {
              n = _ref9[_u];
              n.kind = 'lo_node';
            }
            nodes = [central_node].concat(__slice.call(line.hi), __slice.call(line.other), __slice.call(line.lo));
            nodes.obj = {
              data: line.radical
            };
            _results.push(nodes);
          }
          return _results;
        })();
        return new Graph(lines);
      };

      return CentralStationEmbedder;

    })();
    log2 = function(x) {
      return Math.log(x) / Math.log(2);
    };
    radius = function(base, angle) {
      if ((Math.round(angle / 0.25 / Math.PI)) % 2 === 0) {
        return base;
      } else {
        return Math.sqrt(2 * Math.pow(base, 2));
      }
    };
    someAngle = function(i) {
      var a, angle, b, c, exp;

      if (i <= 1) {
        return angle = i * Math.PI;
      } else {
        exp = Math.floor(log2(i));
        a = Math.pow(2, exp);
        b = Math.pow(2, exp - 1);
        c = 1 + i % a;
        return angle = (1 / a + c / b) * Math.PI;
      }
    };
    return {
      CentralStationEmbedder: CentralStationEmbedder
    };
  });

}).call(this);

/*
//@ sourceMappingURL=central_station.map
*/
