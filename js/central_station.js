// Generated by CoffeeScript 1.6.2
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  define(['utils', 'graph'], function(utils, _arg) {
    var CentralStationEmbedder, Graph, Node, P;

    Graph = _arg.Graph, Node = _arg.Node;
    P = utils.P;
    CentralStationEmbedder = (function() {
      /*
      		Lines get arranged star-like around the central node.
      		Each line has a star point.
      		
      		Lines have three kinds of nodes: hi, lo and other.
      		Lo nodes are nodes with degree one and are on the star point.
      		Hi nodes are nodes with degree bigger one and are on the star point.
      		Other nodes are nodes with degree bigger one and are on another star
      		point.
      		
      		On which star point get nodes with degree bigger one?
      		This is based on a balancing process. Each star point gets so many
      		hi nodes such that it is balanced with each other star point as good as
      		it gets.
      */
      function CentralStationEmbedder(config) {
        this.config = config;
      }

      CentralStationEmbedder.prototype.graph = function(central_kanji, all_radicals, all_kanjis) {
        var angle, central_node, hi, hi_nodes, i, kanji, kanjiDegree, kanjiIsRelated, kanjiNode, kanjiRelevantRadicals, kanji_offset, line, line_i, lines, memo, min, n, node, node_i, node_r, nodes, r, radical, radical_node, related_kanjis, x, y, _, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;

        lines = {};
        _ref = central_kanji.radicals;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          radical = _ref[_i];
          lines[radical.radical] = {
            radical: radical,
            hi: 0,
            lo: [],
            other: null
          };
        }
        related_kanjis = utils.arrayUnique(d3.merge((function() {
          var _j, _len1, _ref1, _results;

          _ref1 = central_kanji.radicals;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            radical = _ref1[_j];
            _results.push(radical.jouyou);
          }
          return _results;
        })()));
        i = related_kanjis.indexOf(central_kanji);
        [].splice.apply(related_kanjis, [i, i - i + 1].concat(_ref1 = [])), _ref1;
        memo = new utils.Memo;
        kanjiIsRelated = memo.onceObj(function(kanji) {
          return __indexOf.call(related_kanjis, kanji) >= 0;
        });
        kanjiRelevantRadicals = memo.onceObj(function(kanji) {
          var _j, _len1, _ref2, _results;

          _ref2 = kanji.radicals;
          _results = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            radical = _ref2[_j];
            if (__indexOf.call(central_kanji.radicals, radical) >= 0) {
              _results.push(radical);
            }
          }
          return _results;
        });
        kanjiDegree = memo.onceObj(function(kanji) {
          return kanjiRelevantRadicals(kanji).length;
        });
        kanjiNode = memo.onceObj(function(kanji) {
          return new Node({
            data: kanji
          });
        });
        hi_nodes = [];
        for (_j = 0, _len1 = related_kanjis.length; _j < _len1; _j++) {
          kanji = related_kanjis[_j];
          node = kanjiNode(kanji);
          if (kanjiDegree(kanji) === 1) {
            node.style.lo = true;
            radical = kanjiRelevantRadicals(kanji)[0];
            lines[radical.radical].lo.push(node);
          } else {
            node.style.hi = true;
            hi_nodes.push(node);
          }
        }
        /* Balancing # XXX not perfect I believe @payload
        			Balancing is done in two phases. First it is counted such that
        			each line gets a balanced amount of hi nodes. Second each node
        			is assigned to a lines hi nodes. This ensures the sorting order
        			of the kanjis which results in a good edge network with minimal
        			connecting nodes. (Connecting nodes are nodes where an edge changes
        			star points.)
        */

        for (_k = 0, _len2 = hi_nodes.length; _k < _len2; _k++) {
          node = hi_nodes[_k];
          min = null;
          _ref2 = kanjiRelevantRadicals(node.data);
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            radical = _ref2[_l];
            line = lines[radical.radical];
            if (min === null || line.hi < min.hi) {
              min = line;
            }
          }
          min.hi++;
        }
        for (_ in lines) {
          line = lines[_];
          hi = line.hi;
          line.hi = hi_nodes.slice(0, hi);
          line.other = hi_nodes.slice(hi);
          [].splice.apply(hi_nodes, [0, hi - 0].concat(_ref3 = [])), _ref3;
        }
        node_r = my.config.gridSpacing * 4;
        kanji_offset = 5;
        central_node = kanjiNode(central_kanji);
        n = central_kanji.radicals.length;
        lines = (function() {
          var _len4, _len5, _m, _n, _ref4, _ref5, _results;

          _ref4 = d3.values(lines);
          _results = [];
          for (line_i = _m = 0, _len4 = _ref4.length; _m < _len4; line_i = ++_m) {
            line = _ref4[line_i];
            angle = line_i / n * Math.PI * 2;
            r = node_r;
            x = r * Math.cos(angle);
            y = r * Math.sin(angle);
            radical_node = new Node({
              x: x,
              y: y,
              data: line.radical
            });
            _ref5 = __slice.call(line.hi).concat(__slice.call(line.lo));
            for (node_i = _n = 0, _len5 = _ref5.length; _n < _len5; node_i = ++_n) {
              node = _ref5[node_i];
              r = (node_i + kanji_offset) * node_r;
              node.x = r * Math.cos(angle);
              node.y = r * Math.sin(angle);
            }
            nodes = [central_node, radical_node].concat(__slice.call(line.hi), __slice.call(line.other), __slice.call(line.lo));
            nodes.obj = {
              data: line.radical
            };
            _results.push(nodes);
          }
          return _results;
        })();
        return new Graph(lines);
      };

      return CentralStationEmbedder;

    })();
    return {
      CentralStationEmbedder: CentralStationEmbedder
    };
  });

}).call(this);

/*
//@ sourceMappingURL=central_station.map
*/
