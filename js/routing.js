// Generated by CoffeeScript 1.6.2
(function() {
  var __slice = [].slice;

  define(['utils', 'grid', 'criteria'], function(utils, _arg, criteria) {
    var Grid, GridCoordGenerator, MetroMapLayout, P, PD, compareNumber, forall, length, metroMap, nearest01, nearestXY, optimizeCriterias, rasterCircle, sortSomewhat;

    Grid = _arg.Grid, GridCoordGenerator = _arg.GridCoordGenerator;
    P = utils.P, PD = utils.PD, forall = utils.forall, nearest01 = utils.nearest01, nearestXY = utils.nearestXY, rasterCircle = utils.rasterCircle, length = utils.length, compareNumber = utils.compareNumber, sortSomewhat = utils.sortSomewhat;
    optimizeCriterias = criteria;
    /*
    
    		Here we stick to the terminology used in Jonathan M. Scotts thesis.
    		http://www.jstott.me.uk/thesis/thesis-final.pdf (main algorithm on page 90)
    		This involved graph, node, edge, metro line, ...
    
    		* data stucture
    			graph = { nodes, edges }
    			node  = { station }
    			edge  = { link }
    			station = { label, cluster,	vector, x, y, kanji, radical, fixed, links }
    			link = { source, target, radical, kanjis}
    			source = { station }
    			target = { station }
    */

    metroMap = function(graph, config) {
      var layout;

      console.time('metroMap');
      layout = new MetroMapLayout({
        config: config,
        graph: graph
      });
      if (config.gridSpacing > 0) {
        layout.snapNodes();
      }
      layout.optimize();
      console.timeEnd('metroMap');
      return graph;
    };
    MetroMapLayout = (function() {
      function MetroMapLayout(_arg1) {
        var node, _i, _len, _ref, _ref1, _ref2;

        _ref = _arg1 != null ? _arg1 : {}, this.config = _ref.config, this.graph = _ref.graph;
        if ((_ref1 = this.config) == null) {
          this.config = {
            timeToOptimize: 100,
            gridSpacing: 1,
            optimizeMaxSteps: 1
          };
        }
        this.grid = new Grid;
        _ref2 = this.graph.nodes || [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          node = _ref2[_i];
          this.grid.set(node, node);
        }
      }

      MetroMapLayout.prototype.snapNodes = function() {
        var b, coord, d, grid, i, list, node, nodes, old_length, toMove, x, y, _i, _len, _name, _ref, _ref1, _ref2, _ref3, _ref4, _results;

        grid = this.grid;
        nodes = this.graph.nodes.slice(0);
        old_length = nodes.length;
        _results = [];
        while (nodes.length > 0) {
          toMove = {};
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            node = nodes[_i];
            _ref = this.nearestFreeGrid(node, grid), x = _ref[0], y = _ref[1];
            ((_ref1 = toMove[_name = x + "x" + y]) != null ? _ref1 : toMove[_name] = []).push(node);
          }
          nodes = [];
          for (coord in toMove) {
            list = toMove[coord];
            _ref2 = (function() {
              var _j, _len1, _ref2, _results1;

              _ref2 = coord.split('x');
              _results1 = [];
              for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                d = _ref2[_j];
                _results1.push(+d);
              }
              return _results1;
            })(), x = _ref2[0], y = _ref2[1];
            _ref3 = nearestXY({
              x: x,
              y: y
            }, list), b = _ref3.b, i = _ref3.i;
            grid.remove(b);
            grid.set([x, y], b);
            [].splice.apply(list, [i, i - i + 1].concat(_ref4 = [])), _ref4;
            nodes = __slice.call(nodes).concat(__slice.call(list));
          }
          if (nodes.length >= old_length) {
            throw "no progress";
          }
          _results.push(old_length = nodes.length);
        }
        return _results;
      };

      MetroMapLayout.prototype.nearestFreeGrid = function(_arg1, grid) {
        var b, coord, coords, g, generator, x, y;

        x = _arg1.x, y = _arg1.y;
        g = this.config.gridSpacing;
        generator = new GridCoordGenerator({
          x: x,
          y: y,
          spacing: g,
          filter: function(coord) {
            return !grid.has(coord);
          }
        });
        coord = [g * Math.round(x / g), g * Math.round(y / g)];
        coords = generator.next();
        if (!grid.has(coord)) {
          coords.push(coord);
        }
        b = nearest01([x, y], coords).b;
        return b;
      };

      MetroMapLayout.prototype.optimize = function(_arg1) {
        var criterias, edges, lines, n, node, nodes, optimizeMaxSteps, stats, time, timeAvailable, _i, _len, _ref, _ref1;

        _ref = _arg1 != null ? _arg1 : {}, timeAvailable = _ref.timeAvailable, criterias = _ref.criterias;
        if (timeAvailable == null) {
          timeAvailable = this.config.timeToOptimize;
        }
        if (criterias == null) {
          criterias = optimizeCriterias;
        }
        optimizeMaxSteps = this.config.optimizeMaxSteps;
        _ref1 = this.graph, nodes = _ref1.nodes, edges = _ref1.edges, lines = _ref1.lines;
        nodes = nodes.slice(0);
        criteria = function(node) {
          var crit, crits, deps, name, value, _i, _len;

          crits = (function() {
            var _results;

            _results = [];
            for (name in criterias) {
              crit = criterias[name];
              _results.push(crit(node));
            }
            return _results;
          })();
          value = 0;
          deps = [];
          for (_i = 0, _len = crits.length; _i < _len; _i++) {
            crit = crits[_i];
            value += crit.value;
            utils.arrayUnique(crit.deps, deps);
          }
          return {
            value: value,
            deps: deps
          };
        };
        stats = {
          moved: {},
          steps: 0,
          bench: []
        };
        time = timeAvailable + Date.now();
        while (time > +Date.now() && stats.steps < optimizeMaxSteps) {
          ++stats.steps;
          this.sortByCriteria(nodes, criteria);
          stats.bench.push(d3.sum((function() {
            var _i, _len, _results;

            _results = [];
            for (_i = 0, _len = nodes.length; _i < _len; _i++) {
              n = nodes[_i];
              _results.push(n.crit.value);
            }
            return _results;
          })()));
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            node = nodes[_i];
            if (!node.crit) {
              node.crit = criteria(node);
            }
            if (node.crit.value > 0) {
              if (this.moveNode(node, criteria)) {
                stats.moved[node.data.kanji] = true;
              }
            }
          }
        }
        this.sortByCriteria(nodes, criteria);
        stats.bench.push(d3.sum((function() {
          var _j, _len1, _results;

          _results = [];
          for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
            n = nodes[_j];
            _results.push(n.crit.value);
          }
          return _results;
        })()));
        stats.moved = length(stats.moved);
        stats.better = stats.bench.slice(-1)[0] / stats.bench[0];
        return {
          stats: stats
        };
      };

      MetroMapLayout.prototype.moveNode = function(node, criteria) {
        var before, coord, coords, copy, generator, min, sum, update, value, x, y, _i, _len, _ref,
          _this = this;

        update = function(crit) {
          var n, _i, _len, _ref, _results;

          _ref = crit.deps;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(n.crit = criteria(n));
          }
          return _results;
        };
        sum = function(crit) {
          var n;

          return crit.value + d3.sum((function() {
            var _i, _len, _ref, _results;

            _ref = crit.deps;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              _results.push(n.crit.value);
            }
            return _results;
          })());
        };
        generator = new GridCoordGenerator({
          x: node.x,
          y: node.y,
          spacing: this.config.gridSpacing,
          filter: function(coord) {
            return !_this.grid.has(coord);
          }
        });
        coords = generator.next();
        coords.push.apply(coords, generator.next());
        copy = {
          x: node.x,
          y: node.y
        };
        update(node.crit);
        before = sum(node.crit);
        min = {
          value: before,
          coord: [node.x, node.y]
        };
        for (_i = 0, _len = coords.length; _i < _len; _i++) {
          coord = coords[_i];
          node.x = coord[0];
          node.y = coord[1];
          node.crit = criteria(node);
          update(node.crit);
          value = sum(node.crit);
          if (value < 0.0001) {
            value = 0;
          }
          if (min.value > value) {
            min.value = value;
            min.coord = coord;
            if (min.value === 0) {
              break;
            }
          }
        }
        _ref = min.coord, x = _ref[0], y = _ref[1];
        if (x !== copy.x || y !== copy.y) {
          this.grid.remove(copy);
          this.grid.set([x, y], node);
          node.crit = criteria(node);
          update(node.crit);
          return node;
        } else {
          node.x = copy.x;
          node.y = copy.y;
          return null;
        }
      };

      MetroMapLayout.prototype.sortByCriteria = function(nodes, criteria) {
        return nodes.sort(function(a, b) {
          var node, _i, _len, _ref;

          _ref = [a, b];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            if (node.crit == null) {
              node.crit = criteria(node);
            }
          }
          return compareNumber(b.crit.value, a.crit.value);
        });
      };

      MetroMapLayout.prototype.calculateNodesCriteria = function(nodes) {
        var edgesOfNode, node, _i, _len;

        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          edgesOfNode = this.getEdgesOfNode(node);
        }
        return [0, 0];
      };

      MetroMapLayout.prototype.getAngularResolutionCriterion = function(edges) {
        var degree, e1, e2, sum, _i, _j, _len, _len1;

        sum = 0;
        degree = edges.length;
        for (_i = 0, _len = edges.length; _i < _len; _i++) {
          e1 = edges[_i];
          for (_j = 0, _len1 = edges.length; _j < _len1; _j++) {
            e2 = edges[_j];
            if (e1 === e2) {
              continue;
            }
            sum += Math.abs((2 * Math.PI / degree) - e1.getAngle(e2));
          }
        }
        return sum;
      };

      MetroMapLayout.prototype.getEdgesOfNode = function(node) {
        var edge, edgesOfNode, kanji, src_kanji, tar_kanji, _i, _len, _ref;

        edgesOfNode = [];
        _ref = this.graph.edges;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          kanji = node.data.kanji;
          src_kanji = edge.source.data.kanji;
          tar_kanji = edge.target.data.kanji;
          if (src_kanji === kanji || tar_kanji === kanji) {
            edgesOfNode.push(edge);
          }
        }
        return edgesOfNode;
      };

      MetroMapLayout.prototype.findLowestNodeCriteria = function(nodes) {
        return 0;
      };

      return MetroMapLayout;

    })();
    return {
      metroMap: metroMap,
      MetroMapLayout: MetroMapLayout,
      optimizeCriterias: optimizeCriterias
    };
  });

}).call(this);

/*
//@ sourceMappingURL=routing.map
*/
