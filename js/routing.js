// Generated by CoffeeScript 1.6.2
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['utils', 'grid'], function(_arg, _arg1) {
    var Grid, GridCoordGenerator, MetroMapLayout, P, PD, compareNumber, forall, length, metroMap, nearest01, nearestXY, rasterCircle, sortSomewhat;

    P = _arg.P, PD = _arg.PD, forall = _arg.forall, nearest01 = _arg.nearest01, nearestXY = _arg.nearestXY, rasterCircle = _arg.rasterCircle, length = _arg.length, compareNumber = _arg.compareNumber, sortSomewhat = _arg.sortSomewhat;
    Grid = _arg1.Grid;
    /*
    
    		Here we stick to the terminology used in Jonathan M. Scotts thesis.
    		http://www.jstott.me.uk/thesis/thesis-final.pdf (main algorithm on page 90)
    		This involved graph, node, edge, metro line, ...
    
    		* data stucture
    			graph = { nodes, edges }
    			node  = { station }
    			edge  = { link }
    			station = { label, cluster,	vector, x, y, kanji, radical, fixed, links }
    			link = { source, target, radical, kanjis}
    			source = { station }
    			target = { station }
    */

    metroMap = function(graph, config) {
      var layout;

      console.time('metroMap');
      layout = new MetroMapLayout({
        config: config,
        graph: graph
      });
      if (config.gridSpacing > 0) {
        layout.snapNodes();
      }
      layout.optimize();
      console.timeEnd('metroMap');
      return graph;
    };
    MetroMapLayout = (function() {
      function MetroMapLayout(_arg2) {
        var node, _i, _len, _ref, _ref1;

        this.config = _arg2.config, this.graph = _arg2.graph;
        this.lineStraightness = __bind(this.lineStraightness, this);
        _ref = this.config, this.timeToOptimize = _ref.timeToOptimize, this.gridSpacing = _ref.gridSpacing;
        this.grid = new Grid;
        _ref1 = this.graph.nodes || [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          node = _ref1[_i];
          this.grid.set(node, node);
        }
      }

      MetroMapLayout.prototype.snapNodes = function() {
        var b, coord, d, grid, i, list, node, nodes, old_length, toMove, x, y, _i, _len, _name, _ref, _ref1, _ref2, _ref3, _ref4, _results;

        grid = this.grid;
        nodes = this.graph.nodes.slice(0);
        old_length = nodes.length;
        _results = [];
        while (nodes.length > 0) {
          toMove = {};
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            node = nodes[_i];
            _ref = this.nearestFreeGrid(node, grid), x = _ref[0], y = _ref[1];
            ((_ref1 = toMove[_name = x + "x" + y]) != null ? _ref1 : toMove[_name] = []).push(node);
          }
          nodes = [];
          for (coord in toMove) {
            list = toMove[coord];
            _ref2 = (function() {
              var _j, _len1, _ref2, _results1;

              _ref2 = coord.split('x');
              _results1 = [];
              for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                d = _ref2[_j];
                _results1.push(+d);
              }
              return _results1;
            })(), x = _ref2[0], y = _ref2[1];
            _ref3 = nearestXY({
              x: x,
              y: y
            }, list), b = _ref3.b, i = _ref3.i;
            grid.remove(b);
            grid.set([x, y], b);
            [].splice.apply(list, [i, i - i + 1].concat(_ref4 = [])), _ref4;
            nodes = __slice.call(nodes).concat(__slice.call(list));
          }
          if (nodes.length >= old_length) {
            throw "no progress";
          }
          _results.push(old_length = nodes.length);
        }
        return _results;
      };

      MetroMapLayout.prototype.nearestFreeGrid = function(_arg2, grid) {
        var b, coord, coords, g, generator, x, y;

        x = _arg2.x, y = _arg2.y;
        g = this.gridSpacing;
        generator = new GridCoordGenerator({
          x: x,
          y: y,
          spacing: g,
          filter: function(coord) {
            return !grid.has(coord);
          }
        });
        coord = [g * Math.round(x / g), g * Math.round(y / g)];
        coords = generator.next();
        if (!grid.has(coord)) {
          coords.push(coord);
        }
        b = nearest01([x, y], coords).b;
        return b;
      };

      MetroMapLayout.prototype.optimize = function(timeAvailable) {
        var bench, edges, lines, moved, n, node, nodes, stats, steps, time, _i, _len, _ref;

        if (timeAvailable == null) {
          timeAvailable = this.timeToOptimize;
        }
        _ref = this.graph, nodes = _ref.nodes, edges = _ref.edges, lines = _ref.lines;
        nodes = nodes.slice(0);
        time = timeAvailable + Date.now();
        moved = {};
        steps = 0;
        bench = [];
        while (time > +Date.now() && steps < this.config.optimizeMaxSteps) {
          ++steps;
          this.sortByCriteria(nodes, this.lineStraightness);
          bench.push(d3.sum((function() {
            var _i, _len, _results;

            _results = [];
            for (_i = 0, _len = nodes.length; _i < _len; _i++) {
              n = nodes[_i];
              _results.push(n.crit.value);
            }
            return _results;
          })()));
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            node = nodes[_i];
            if (!node.crit) {
              node.crit = this.lineStraightness(node);
            }
            if (node.crit.value > 0) {
              if (this.moveNode(node, this.lineStraightness)) {
                moved[node.data.kanji] = true;
              }
            }
          }
        }
        this.sortByCriteria(nodes, this.lineStraightness);
        bench.push(d3.sum((function() {
          var _j, _len1, _results;

          _results = [];
          for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
            n = nodes[_j];
            _results.push(n.crit.value);
          }
          return _results;
        })()));
        stats = {
          moved: length(moved),
          steps: steps,
          bench: bench.slice(-1)[0] / bench[0]
        };
        return {
          stats: stats
        };
      };

      MetroMapLayout.prototype.moveNode = function(node, criteria) {
        var before, coord, coords, copy, generator, min, sum, update, value, x, y, _i, _len, _ref,
          _this = this;

        update = function(crit) {
          var n, _i, _len, _ref, _results;

          _ref = crit.deps;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push(n.crit = criteria(n));
          }
          return _results;
        };
        sum = function(crit) {
          var n;

          return crit.value + d3.sum((function() {
            var _i, _len, _ref, _results;

            _ref = crit.deps;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              _results.push(n.crit.value);
            }
            return _results;
          })());
        };
        generator = new GridCoordGenerator({
          x: node.x,
          y: node.y,
          spacing: this.gridSpacing,
          filter: function(coord) {
            return !_this.grid.has(coord);
          }
        });
        coords = generator.next();
        coords.push.apply(coords, generator.next());
        copy = {
          x: node.x,
          y: node.y
        };
        update(node.crit);
        before = sum(node.crit);
        min = {
          value: before,
          coord: [node.x, node.y]
        };
        for (_i = 0, _len = coords.length; _i < _len; _i++) {
          coord = coords[_i];
          node.x = coord[0];
          node.y = coord[1];
          node.crit = criteria(node);
          update(node.crit);
          value = sum(node.crit);
          if (value < 0.0001) {
            value = 0;
          }
          if (min.value > value) {
            min.value = value;
            min.coord = coord;
            if (min.value === 0) {
              break;
            }
          }
        }
        _ref = min.coord, x = _ref[0], y = _ref[1];
        if (x !== copy.x || y !== copy.y) {
          this.grid.remove(copy);
          this.grid.set([x, y], node);
          node.crit = criteria(node);
          update(node.crit);
          return node;
        } else {
          node.x = copy.x;
          node.y = copy.y;
          return null;
        }
      };

      MetroMapLayout.prototype.sortByCriteria = function(nodes, criteria) {
        return nodes.sort(function(a, b) {
          var node, _i, _len, _ref;

          _ref = [a, b];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            if (node.crit == null) {
              node.crit = criteria(node);
            }
          }
          return compareNumber(b.crit.value, a.crit.value);
        });
      };

      MetroMapLayout.prototype.lineStraightness = function(node) {
        var a, angle, angles, b, deps, edge, edges, line, n, other, other_node, segment, segments, straightness, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;

        segments = {};
        _ref = node.lines;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          segments[line.id] = [];
        }
        _ref1 = node.edges;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          edge = _ref1[_j];
          other_node = this.otherNode(node, edge);
          other = this.otherEdge(other_node, edge);
          segment = segments[edge.line.id];
          segment.push(edge);
          if (other) {
            segment.push(other);
          }
        }
        deps = [];
        for (line in segments) {
          edges = segments[line];
          for (_k = 0, _len2 = edges.length; _k < _len2; _k++) {
            edge = edges[_k];
            _ref2 = [edge.source, edge.target];
            for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
              n = _ref2[_l];
              if (n !== node && __indexOf.call(deps, n) < 0) {
                deps.push(n);
              }
            }
          }
        }
        angles = (function() {
          var _results;

          _results = [];
          for (line in segments) {
            edges = segments[line];
            edges = sortSomewhat(edges, function(a, b) {
              if (a.target === b.source) {
                return -1;
              }
              if (a.source === b.target) {
                return 1;
              }
            });
            a = edges[0];
            _results.push((function() {
              var _len4, _m, _ref3, _results1;

              _ref3 = edges.slice(1);
              _results1 = [];
              for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
                b = _ref3[_m];
                angle = a.getAngle(b);
                angle = Math.pow(angle, 2);
                if (angle < 0.00001) {
                  _results1.push(0);
                } else {
                  _results1.push(angle);
                }
              }
              return _results1;
            })());
          }
          return _results;
        })();
        straightness = d3.sum(d3.merge(angles));
        return {
          value: straightness,
          deps: deps
        };
      };

      MetroMapLayout.prototype.otherNode = function(node, edge) {
        if (edge.source === node) {
          return edge.target;
        } else {
          return edge.source;
        }
      };

      MetroMapLayout.prototype.otherEdge = function(node, edge) {
        var other, _i, _len, _ref;

        _ref = node.edges;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          other = _ref[_i];
          if (other === edge) {
            continue;
          }
          if (other.line.id === edge.line.id) {
            return other;
          }
        }
        return null;
      };

      MetroMapLayout.prototype.calculateNodesCriteria = function(nodes) {
        var edgesOfNode, node, _i, _len;

        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          edgesOfNode = this.getEdgesOfNode(node);
        }
        return [0, 0];
      };

      MetroMapLayout.prototype.getAngularResolutionCriterion = function(edges) {
        var degree, e1, e2, sum, _i, _j, _len, _len1;

        sum = 0;
        degree = edges.length;
        for (_i = 0, _len = edges.length; _i < _len; _i++) {
          e1 = edges[_i];
          for (_j = 0, _len1 = edges.length; _j < _len1; _j++) {
            e2 = edges[_j];
            if (e1 === e2) {
              continue;
            }
            sum += Math.abs((2 * Math.PI / degree) - e1.getAngle(e2));
          }
        }
        return sum;
      };

      MetroMapLayout.prototype.getEdgesOfNode = function(node) {
        var edge, edgesOfNode, kanji, src_kanji, tar_kanji, _i, _len, _ref;

        edgesOfNode = [];
        _ref = this.graph.edges;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          kanji = node.data.kanji;
          src_kanji = edge.source.data.kanji;
          tar_kanji = edge.target.data.kanji;
          if (src_kanji === kanji || tar_kanji === kanji) {
            edgesOfNode.push(edge);
          }
        }
        return edgesOfNode;
      };

      MetroMapLayout.prototype.findLowestNodeCriteria = function(nodes) {
        return 0;
      };

      return MetroMapLayout;

    })();
    GridCoordGenerator = (function() {
      function GridCoordGenerator(_arg2) {
        var _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

        _ref = _arg2 != null ? _arg2 : {}, this.g = _ref.spacing, this.filter = _ref.filter, this.r = _ref.r, this.x = _ref.x, this.y = _ref.y;
        if ((_ref1 = this.r) == null) {
          this.r = 1;
        }
        if ((_ref2 = this.x) == null) {
          this.x = 0;
        }
        if ((_ref3 = this.y) == null) {
          this.y = 0;
        }
        if ((_ref4 = this.g) == null) {
          this.g = 1;
        }
        if ((_ref5 = this.filter) == null) {
          this.filter = function() {
            return true;
          };
        }
      }

      GridCoordGenerator.prototype.next = function() {
        var c, coord, coords, filter, g, gx, gy, x, y;

        g = this.g, filter = this.filter, x = this.x, y = this.y;
        gx = g * Math.round(x / g);
        gy = g * Math.round(y / g);
        coords = [];
        while (coords.length === 0) {
          coords = this.coords(this.r++);
          coords = (function() {
            var _i, _len, _results;

            _results = [];
            for (_i = 0, _len = coords.length; _i < _len; _i++) {
              c = coords[_i];
              _results.push([gx + g * c[0], gy + g * c[1]]);
            }
            return _results;
          })();
          coords = (function() {
            var _i, _len, _results;

            _results = [];
            for (_i = 0, _len = coords.length; _i < _len; _i++) {
              coord = coords[_i];
              if (filter(coord)) {
                _results.push(coord);
              }
            }
            return _results;
          })();
        }
        return coords;
      };

      GridCoordGenerator.prototype.coords = function(r) {
        var coords, x, y, _i;

        coords = [];
        for (x = _i = 0; 0 <= r ? _i <= r : _i >= r; x = 0 <= r ? ++_i : --_i) {
          y = r - Math.abs(x);
          coords.push([+x, +y]);
          coords.push([-x, -y]);
          if (x !== 0 && y !== 0) {
            coords.push([-x, +y]);
          }
          if (x !== 0 && y !== 0) {
            coords.push([+x, -y]);
          }
        }
        return coords;
      };

      return GridCoordGenerator;

    })();
    return {
      metroMap: metroMap,
      MetroMapLayout: MetroMapLayout
    };
  });

}).call(this);

/*
//@ sourceMappingURL=routing.map
*/
