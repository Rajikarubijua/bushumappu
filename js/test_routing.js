// Generated by CoffeeScript 1.6.2
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  define(['utils', 'routing', 'graph', 'tests'], function(_arg, routing, _arg1, T) {
    var Edge, Line, Node, P, PD, allAreSnapped, angleIsRight, coordIsRight1, coordIsRight2, createGraph, criteriaIsNull, criteriaIsRight, debug, movement, noMovement, noOverlap, oneIsAtZero, optimal, runTests, testConfig, tests;

    P = _arg.P, PD = _arg.PD;
    Node = _arg1.Node, Edge = _arg1.Edge, Line = _arg1.Line;
    tests = {
      testSnapNodes: function() {
        var config, g, test;

        config = testConfig;
        g = config.gridSpacing;
        test = function(name, graph, criteria) {
          var layout;

          console.info("     " + name);
          graph = createGraph(graph);
          layout = new routing.MetroMapLayout({
            config: config,
            graph: graph
          });
          layout.snapNodes();
          return T.assert(name, graph.nodes, config, criteria);
        };
        test("single node", [
          [
            {
              x: -1,
              y: -1
            }
          ]
        ], {
          oneIsAtZero: oneIsAtZero,
          allAreSnapped: allAreSnapped
        });
        test("two, different grid", [
          [
            {
              x: -1,
              y: -1
            }, {
              x: -1 + g,
              y: -1 + g
            }
          ]
        ], {
          oneIsAtZero: oneIsAtZero,
          allAreSnapped: allAreSnapped
        });
        test("two, same distance", [
          [
            {
              x: -1,
              y: -1
            }, {
              x: 1,
              y: 1
            }
          ]
        ], {
          oneIsAtZero: oneIsAtZero,
          allAreSnapped: allAreSnapped
        });
        return test("ten, same position", [
          (function() {
            var _i, _results;

            _results = [];
            for (_i = 1; _i <= 10; _i++) {
              _results.push({
                x: 0,
                y: 0
              });
            }
            return _results;
          })()
        ], {
          oneIsAtZero: oneIsAtZero,
          allAreSnapped: allAreSnapped
        });
      },
      testAngularResolutionCriterion: function() {
        var config, edge1, edge2, edge3, edges1, edges2, test;

        config = testConfig;
        test = function(name, edges, criteria) {
          var layout;

          console.info("     " + name);
          layout = new routing.MetroMapLayout({
            config: config,
            graph: {
              edges: edges
            }
          });
          return T.assert(name, edges, config, criteria);
        };
        edge1 = new Edge({
          target: {
            x: 5,
            y: 1
          },
          source: {
            x: 1,
            y: 1
          }
        });
        edge2 = new Edge({
          target: {
            x: 1,
            y: 1
          },
          source: {
            x: 3,
            y: 3
          }
        });
        edge3 = new Edge({
          target: {
            x: -2,
            y: 1
          },
          source: {
            x: 1,
            y: 1
          }
        });
        edges1 = [edge1, edge3];
        edges2 = [edge1, edge2];
        test("edge.getVector() test1", [edge1], {
          coordIsRight1: coordIsRight1
        });
        test("edge.getVector() test2", [edge2], {
          coordIsRight2: coordIsRight2
        });
        test("edge.getAngle() test", edges2, {
          angleIsRight: angleIsRight
        });
        test("test perfect single edge", [edge1], {
          criteriaIsNull: criteriaIsNull
        });
        test("test perfect multiple edge", edges1, {
          criteriaIsNull: criteriaIsNull
        });
        return test("test multiple edge", edges2, {
          criteriaIsRight: criteriaIsRight
        });
      },
      testOptimizeLineStraightness: function() {
        var a, b, c, config, d, e, test;

        config = testConfig;
        config.gridSpacing = 1;
        test = function(name, graph, criteria) {
          var critsAfter, critsBefore, graphA, graphB, graphCriteria, layout, node, stats, value;

          console.info("     " + name);
          graphA = createGraph(graph);
          graphB = createGraph(graph);
          layout = new routing.MetroMapLayout({
            config: config,
            graph: graphB
          });
          graphCriteria = layout.lineStraightness;
          stats = layout.optimize(100).stats;
          critsBefore = (function() {
            var _i, _len, _ref, _results;

            _ref = graphA.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              _results.push((graphCriteria(node)).value);
            }
            return _results;
          })();
          critsAfter = (function() {
            var _i, _len, _ref, _results;

            _ref = graphB.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              _results.push((graphCriteria(node)).value);
            }
            return _results;
          })();
          value = {
            graphA: graphA,
            graphB: graphB,
            criteria: graphCriteria,
            stats: stats,
            critsBefore: critsBefore,
            critsAfter: critsAfter
          };
          T.assert(name, value, config, criteria);
          return graphB;
        };
        a = {
          x: -1,
          y: 0,
          id: 'a'
        };
        b = {
          x: 0,
          y: 0,
          id: 'b'
        };
        c = {
          x: 1,
          y: 0,
          id: 'c'
        };
        test("single line, optimal", [[a, b, c]], {
          noMovement: noMovement,
          optimal: optimal,
          noOverlap: noOverlap
        });
        b = {
          x: 0,
          y: 1,
          id: 'b'
        };
        debug(function() {
          return test("single line, single error", [[a, b, c]], {
            movement: movement,
            optimal: optimal,
            noOverlap: noOverlap
          });
        });
        b = {
          x: 0,
          y: 0,
          id: 'b'
        };
        d = {
          x: 0,
          y: -1,
          id: 'd'
        };
        e = {
          x: 0,
          y: 1,
          id: 'e'
        };
        test("two lines, optimal", [[a, b, c], [d, b, e]], {
          noMovement: noMovement,
          optimal: optimal,
          noOverlap: noOverlap
        });
        b = {
          x: 1,
          y: 1,
          id: 'b'
        };
        test("two lines, single error", [[a, b, c], [d, b, e]], {
          movement: movement,
          optimal: optimal,
          noOverlap: noOverlap
        });
        a = {
          x: -1,
          y: -1,
          id: 'a'
        };
        b = {
          x: 1,
          y: -1,
          id: 'b'
        };
        c = {
          x: 1,
          y: 1,
          id: 'c'
        };
        d = {
          x: -1,
          y: 1,
          id: 'd'
        };
        config.optimizeMaxSteps = 3;
        test("one line, U turn", [[a, b, c, d]], {
          movement: movement,
          optimal: optimal,
          noOverlap: noOverlap
        });
        return config.optimizeMaxSteps = 1;
      },
      testLineStraightness: function() {
        var a, b, c, config, d, result, test;

        config = testConfig;
        test = function(name, graph, result) {
          var layout, node, values;

          graph = createGraph(graph);
          layout = new routing.MetroMapLayout({
            config: config,
            graph: graph
          });
          values = (function() {
            var _i, _len, _ref, _results;

            _ref = graph.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              _results.push((layout.lineStraightness(node)).value);
            }
            return _results;
          })();
          T.assert(name, null, null, {
            correct: function() {
              var correct, i, r, v;

              correct = (function() {
                var _i, _len, _results;

                _results = [];
                for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {
                  v = values[i];
                  r = result[i];
                  if (r === 0) {
                    _results.push(v === 0);
                  } else if (r === true) {
                    _results.push(v > 0);
                  } else {
                    _results.push(true);
                  }
                }
                return _results;
              })();
              return [!(__indexOf.call(correct, false) >= 0), values];
            }
          });
          return values;
        };
        a = {
          x: -1,
          y: 0,
          id: 'a'
        };
        b = {
          x: 0,
          y: 0,
          id: 'b'
        };
        c = {
          x: 1,
          y: 0,
          id: 'c'
        };
        d = {
          x: 2,
          y: 0,
          id: 'd'
        };
        result = [0, 0, 0, 0];
        test('', [[a, b, c, d]], result);
        a = {
          x: -1,
          y: 0,
          id: 'a'
        };
        b = {
          x: 0,
          y: 1,
          id: 'b'
        };
        c = {
          x: 1,
          y: 0,
          id: 'c'
        };
        d = {
          x: 2,
          y: 0,
          id: 'd'
        };
        result = [true, true, true, true];
        test('', [[a, b, c, d]], result);
        a = {
          x: -1,
          y: 0,
          id: 'a'
        };
        b = {
          x: 0,
          y: 1,
          id: 'b'
        };
        c = {
          x: 1,
          y: 1,
          id: 'c'
        };
        d = {
          x: 2,
          y: 0,
          id: 'd'
        };
        result = [true, true, true, true];
        test('', [[a, b, c, d]], result);
        a = {
          x: -1,
          y: 0,
          id: 'a'
        };
        b = {
          x: -1,
          y: 1,
          id: 'b'
        };
        c = {
          x: 1,
          y: 1,
          id: 'c'
        };
        d = {
          x: 1,
          y: 0,
          id: 'd'
        };
        result = [true, true, true, true];
        test('', [[a, b, c, d]], result);
        a = {
          x: -1,
          y: -1,
          id: 'a'
        };
        b = {
          x: 0,
          y: 0,
          id: 'b'
        };
        c = {
          x: 1,
          y: 1,
          id: 'c'
        };
        d = {
          x: 2,
          y: 2,
          id: 'd'
        };
        result = [0, 0, 0, 0];
        return test('', [[a, b, c, d]], result);
      }
    };
    debug = function(func) {
      my.debug = true;
      func();
      return my.debug = false;
    };
    createGraph = function(lines) {
      var edge, graph, line, line_nodes, node, nodes, orig_line_nodes, source, target, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;

      graph = {
        nodes: [],
        edges: [],
        lines: []
      };
      nodes = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line_nodes = lines[_i];
        for (_j = 0, _len1 = line_nodes.length; _j < _len1; _j++) {
          node = line_nodes[_j];
          if (__indexOf.call(nodes, node) < 0) {
            nodes.push(node);
          }
        }
      }
      graph.nodes = (function() {
        var _k, _len2, _results;

        _results = [];
        for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
          node = nodes[_k];
          _results.push(new Node(node));
        }
        return _results;
      })();
      graph.lines = (function() {
        var _k, _len2, _results;

        _results = [];
        for (_k = 0, _len2 = lines.length; _k < _len2; _k++) {
          orig_line_nodes = lines[_k];
          line = new Line;
          line.nodes = (function() {
            var _l, _len3, _results1;

            _results1 = [];
            for (_l = 0, _len3 = orig_line_nodes.length; _l < _len3; _l++) {
              node = orig_line_nodes[_l];
              node = graph.nodes[nodes.indexOf(node)];
              node.lines.push(line);
              _results1.push(node);
            }
            return _results1;
          })();
          _results.push(line);
        }
        return _results;
      })();
      _ref = graph.lines;
      for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
        line = _ref[_k];
        source = line.nodes[0];
        _ref1 = line.nodes.slice(1);
        for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
          target = _ref1[_l];
          edge = new Edge({
            source: source,
            target: target,
            line: line
          });
          source.edges.push(edge);
          target.edges.push(edge);
          graph.edges.push(edge);
          line.edges.push(edge);
          source = target;
        }
      }
      return graph;
    };
    noOverlap = function(_arg2) {
      var a, b, graphB, _i, _j, _len, _len1, _ref, _ref1;

      graphB = _arg2.graphB;
      _ref = graphB.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        _ref1 = graphB.nodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          b = _ref1[_j];
          if (a === b) {
            continue;
          }
          if (a.x === b.x && a.y === b.y) {
            return false;
          }
        }
      }
      return true;
    };
    noMovement = function() {
      var args, result;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = movement.apply(null, args);
      if (Array.isArray(result)) {
        result[0] = !result[0];
      } else {
        result = !result;
      }
      return result;
    };
    movement = function(_arg2) {
      var a, b, graphA, graphB, i, moved, o, _i, _len, _ref;

      graphA = _arg2.graphA, graphB = _arg2.graphB;
      moved = [];
      _ref = graphA.nodes;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        a = _ref[i];
        b = graphB.nodes[i];
        if (!(a.x === b.x && a.y === b.y)) {
          (o = {})[a.id] = [[a.x, a.y], [b.x, b.y]];
          moved.push(o);
        }
      }
      if (moved.length) {
        return [true, moved];
      } else {
        return false;
      }
    };
    optimal = function(_arg2) {
      var criteria, graphB, node, v, values, _i, _len;

      graphB = _arg2.graphB, criteria = _arg2.criteria;
      values = (function() {
        var _i, _len, _ref, _results;

        _ref = graphB.nodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          _results.push([node.id, (criteria(node)).value]);
        }
        return _results;
      })();
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        v = values[_i];
        if (v[1] !== 0) {
          return [false, values];
        }
      }
      return [true, values];
    };
    oneIsAtZero = function(nodes) {
      var node, _i, _len;

      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        if (node.x === 0 && node.y === 0) {
          return true;
        }
      }
      return false;
    };
    allAreSnapped = function(nodes, _arg2) {
      var gridSpacing, node, _i, _len;

      gridSpacing = _arg2.gridSpacing;
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        if (node.x % gridSpacing !== 0 || node.y % gridSpacing !== 0) {
          return false;
        }
      }
      return true;
    };
    coordIsRight1 = function(edges) {
      var vec;

      vec = edges[0].getVector();
      if (vec[0] === 4 & vec[1] === 0) {
        return true;
      }
      P(vec);
      return false;
    };
    coordIsRight2 = function(edges) {
      var vec;

      vec = edges[0].getVector();
      if (vec[0] === -2 & vec[1] === -2) {
        return true;
      }
      P(vec);
      return false;
    };
    angleIsRight = function(edges) {
      var angle, output;

      angle = edges[0].getAngle(edges[1]);
      output = Math.acos((-8) / (4 * Math.sqrt(8)));
      if (angle === output) {
        return true;
      }
      P(angle);
      return false;
    };
    criteriaIsNull = function(edges, config) {
      var layout, sum;

      layout = new routing.MetroMapLayout({
        config: config,
        graph: {
          edges: edges
        }
      });
      sum = layout.getAngularResolutionCriterion(edges);
      if (sum === 0) {
        return true;
      }
      P(sum);
      return false;
    };
    criteriaIsRight = function(edges, config) {
      var layout, optim, sum;

      layout = new routing.MetroMapLayout({
        config: config,
        graph: {
          edges: edges
        }
      });
      sum = layout.getAngularResolutionCriterion(edges);
      optim = ((2 * Math.PI) / edges.length) - Math.acos((-8) / (4 * Math.sqrt(8)));
      if (sum === optim * 2) {
        return true;
      }
      P(optim);
      P(sum);
      return false;
    };
    testConfig = {
      timeToOptimize: 1000,
      gridSpacing: 3,
      optimizeMaxSteps: 1
    };
    runTests = function(which) {
      return T.run(tests, which);
    };
    return {
      runTests: runTests
    };
  });

}).call(this);

/*
//@ sourceMappingURL=test_routing.map
*/
