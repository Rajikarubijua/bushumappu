// Generated by CoffeeScript 1.8.0
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define('graph', ['utils', 'criteria', 'tubeEdges'], function(utils, criteria, tube) {
    var Cluster, Edge, Graph, Line, Node, P;
    P = utils.P;
    Node = (function() {
      var next_id;

      next_id = 0;

      function Node(_arg) {
        var _ref;
        _ref = _arg != null ? _arg : {}, this.x = _ref.x, this.y = _ref.y, this.lines = _ref.lines, this.edges = _ref.edges, this.data = _ref.data, this.style = _ref.style, this.id = _ref.id, this.kind = _ref.kind;
        if (this.x == null) {
          this.x = 0;
        }
        if (this.y == null) {
          this.y = 0;
        }
        if (this.lines == null) {
          this.lines = [];
        }
        if (this.edges == null) {
          this.edges = [];
        }
        if (this.data == null) {
          this.data = {};
        }
        if (this.style == null) {
          this.style = {};
        }
        if (this.id == null) {
          this.id = next_id++;
        }
        if (this.kind == null) {
          this.kind = '';
        }
      }

      Node.prototype.coord = function() {
        return this.x + "x" + this.y;
      };

      Node.prototype.deps = function(n) {
        var deps, node, o, _i, _j, _len, _len1, _ref, _ref1;
        if (n == null) {
          n = 0;
        }
        if (!n && (this._deps != null)) {
          return this._deps;
        }
        deps = this.nextNodes().slice(0);
        if (n === 1) {
          return deps;
        } else {
          _ref = this.nextNodes();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            _ref1 = node.deps(n + 1);
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              o = _ref1[_j];
              if (__indexOf.call(deps, o) < 0) {
                deps.push(o);
              }
            }
          }
          return this._deps = deps;
        }
      };

      Node.prototype.nextNodes = function() {
        var edge;
        return this._nextNodes != null ? this._nextNodes : this._nextNodes = utils.arrayUnique((function() {
          var _i, _len, _ref, _results;
          _ref = this.edges;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            edge = _ref[_i];
            _results.push(this.otherNode(edge));
          }
          return _results;
        }).call(this));
      };

      Node.prototype.ruleViolations = function(graph) {
        return this._ruleViolations != null ? this._ruleViolations : this._ruleViolations = (function(_this) {
          return function() {
            if (!(graph instanceof Graph)) {
              throw "graph not a Graph";
            }
            return d3.sum([1000 * criteria.wrongEdgesUnderneath(_this, graph.edges).length, criteria.edgeCrossings(_this.edges, graph.edges), 100 * criteria.tooNearCentralNode(_this)]);
          };
        })(this)();
      };

      Node.prototype.critQuality = function(graph) {
        return this._critQuality != null ? this._critQuality : this._critQuality = (function(_this) {
          return function() {
            if (!(graph instanceof Graph)) {
              throw "graph not a Graph";
            }
            return criteria.lineStraightness(_this);
          };
        })(this)();
      };

      Node.prototype._invalidateCache = function() {
        return this._critQuality = this._ruleViolations = void 0;
      };

      Node.prototype.move = function(x, y) {
        var edge, node, _i, _j, _len, _len1, _ref, _ref1, _results;
        this.x = x;
        this.y = y;
        if (!((this.x != null) && (this.y != null))) {
          throw "move to undefined";
        }
        this._invalidateCache();
        _ref = this.deps();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          node._invalidateCache();
        }
        _ref1 = this.edges;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          edge = _ref1[_j];
          _results.push(edge._invalidateCache());
        }
        return _results;
      };

      Node.prototype.moveBy = function(x, y) {
        return this.move(this.x + x, this.y + y);
      };

      Node.prototype.otherNode = function(edge) {
        if (edge.source === this) {
          return edge.target;
        } else {
          return edge.source;
        }
      };

      Node.prototype.tubes = function() {
        var edge, tubes, _i, _len, _ref, _ref1;
        tubes = [];
        _ref = this.edges;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          if (_ref1 = edge.tube, __indexOf.call(tubes, _ref1) < 0) {
            tubes.push(edge.tube);
          }
        }
        return tubes;
      };

      Node.prototype.key = function() {
        return this.coord();
      };

      Node.prototype.label = function() {
        return this.data.kanji || this.data.radical || "?";
      };

      return Node;

    })();
    Edge = (function() {
      function Edge(_arg) {
        var _ref;
        _ref = _arg != null ? _arg : {}, this.source = _ref.source, this.target = _ref.target, this.tube = _ref.tube, this.line = _ref.line, this.style = _ref.style;
        this.distanceToNode = __bind(this.distanceToNode, this);
        if (this.source == null) {
          this.source = null;
        }
        if (this.target == null) {
          this.target = null;
        }
        if (this.tube == null) {
          this.tube = null;
        }
        if (this.line == null) {
          this.line = null;
        }
        if (this.style == null) {
          this.style = {};
        }
      }

      Edge.prototype.getVector = function() {
        return [this.target.x - this.source.x, this.target.y - this.source.y];
      };

      Edge.prototype.getAngle = function(edge) {
        var angle, l, l1, l2, scalar, x1, x2, y1, y2, _ref, _ref1;
        _ref = this.getVector(), x1 = _ref[0], y1 = _ref[1];
        _ref1 = edge.getVector(), x2 = _ref1[0], y2 = _ref1[1];
        scalar = x1 * x2 + y1 * y2;
        l1 = this.length();
        l2 = edge.length();
        l = l1 * l2;
        if (Math.abs(scalar - l) < 0.0001) {
          l = scalar;
        }
        return angle = Math.acos(scalar / l);
      };

      Edge.prototype.getEdgeAngle = function() {
        return this._getEdgeAngle != null ? this._getEdgeAngle : this._getEdgeAngle = (function(_this) {
          return function() {
            var angle, x, x1, x2, y, y1, y2, _ref, _ref1;
            _ref = [_this.source.x, _this.source.y], x1 = _ref[0], y1 = _ref[1];
            _ref1 = [_this.target.x, _this.target.y], x2 = _ref1[0], y2 = _ref1[1];
            x = x2 - x1;
            y = y2 - y1;
            return angle = Math.atan2(y, x);
          };
        })(this)();
      };

      Edge.prototype.firstAngleFromNode = function(_arg) {
        var a, a1, a2, angle, b, b1, b2, d1, d2, p, x, y, _ref, _ref1;
        x = _arg.x, y = _arg.y;
        p = [x, y];
        _ref = this.coords().slice(0, 2), a1 = _ref[0], b1 = _ref[1];
        _ref1 = this.coords().slice(-2), b2 = _ref1[0], a2 = _ref1[1];
        d1 = utils.distanceSqr01(p, a1);
        d2 = utils.distanceSqr01(p, a2);
        if (d1 < d2) {
          a = a1;
          b = b1;
        } else {
          a = a2;
          b = b2;
        }
        return angle = utils.angleBetween01(a, b);
      };

      Edge.prototype.lengthSqr = function() {
        return this._lengthSqr != null ? this._lengthSqr : this._lengthSqr = (function(_this) {
          return function() {
            var x, y, _ref;
            _ref = _this.getVector(), x = _ref[0], y = _ref[1];
            return (Math.pow(x, 2)) + (Math.pow(y, 2));
          };
        })(this)();
      };

      Edge.prototype.length = function() {
        return this._length != null ? this._length : this._length = Math.sqrt(this.lengthSqr());
      };

      Edge.prototype.otherEdge = function(edges) {
        var other, _i, _len;
        for (_i = 0, _len = edges.length; _i < _len; _i++) {
          other = edges[_i];
          if (other === this) {
            continue;
          }
          if (other.line.id === this.line.id) {
            return other;
          }
        }
        return null;
      };

      Edge.prototype.isCrossing = function(_arg) {
        var a, b, c, source, target, x1, x2, x3, x4, y1, y2, y3, y4, _ref, _ref1;
        source = _arg.source, target = _arg.target;
        _ref = this.source, x1 = _ref.x, y1 = _ref.y;
        _ref1 = this.target, x2 = _ref1.x, y2 = _ref1.y;
        x3 = source.x, y3 = source.y;
        x4 = target.x, y4 = target.y;
        a = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
        b = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
        c = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        a /= c;
        b /= c;
        return (0 <= a && a <= 1) && (0 <= b && b <= 1);
      };

      Edge.prototype.setCoords = function(coords) {
        return this._coords = coords;
      };

      Edge.prototype.coords = function() {
        if (this._coords == null) {
          tube.createTubes(this);
        }
        return this._coords;
      };

      Edge.prototype._invalidateCache = function() {
        return this._coords = this._lengthSqr = this._length = this._getEdgeAngle = void 0;
      };

      Edge.prototype.key = function() {
        return this.source.key() + " " + this.target.key();
      };

      Edge.prototype.distanceToNode = function(node) {
        var _base, _name;
        if (this._distanceToNode == null) {
          this._distanceToNode = {};
        }
        return (_base = this._distanceToNode)[_name = node.id] != null ? _base[_name] : _base[_name] = (function(_this) {
          return function() {
            var n, next, queue, visited, _i, _len;
            visited = [node];
            queue = [node];
            while (queue.length) {
              node = queue.pop();
              if (__indexOf.call(node.edges, _this) >= 0) {
                return visited.length - 1;
              }
              next = node.nextNodes();
              for (_i = 0, _len = next.length; _i < _len; _i++) {
                n = next[_i];
                if (__indexOf.call(visited, n) < 0) {
                  visited.push(n);
                  queue.push(n);
                }
              }
            }
            return Infinity;
          };
        })(this)();
      };

      return Edge;

    })();
    Line = (function() {
      var next_id;

      next_id = 0;

      function Line(_arg) {
        var _ref;
        _ref = _arg != null ? _arg : {}, this.nodes = _ref.nodes, this.edges = _ref.edges, this.data = _ref.data, this.id = _ref.id;
        if (this.nodes == null) {
          this.nodes = [];
        }
        if (this.edges == null) {
          this.edges = [];
        }
        if (this.data == null) {
          this.data = {};
        }
        if (this.id == null) {
          this.id = next_id++;
        }
      }

      return Line;

    })();
    Graph = (function() {
      function Graph(lines) {
        var edge, k, line, line_nodes, node, nodes, orig_line_nodes, source, target, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
        this.nodes = [];
        this.edges = [];
        this.lines = [];
        this.nodesById = {};
        nodes = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line_nodes = lines[_i];
          for (_j = 0, _len1 = line_nodes.length; _j < _len1; _j++) {
            node = line_nodes[_j];
            if (__indexOf.call(nodes, node) < 0) {
              nodes.push(node);
            }
          }
        }
        this.nodes = (function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
            node = nodes[_k];
            k = 0;
            if (node instanceof Node) {
              _results.push(node);
            } else {
              _results.push(new Node(node));
            }
          }
          return _results;
        })();
        this.lines = (function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = lines.length; _k < _len2; _k++) {
            orig_line_nodes = lines[_k];
            line = new Line(orig_line_nodes.obj);
            line.nodes = (function() {
              var _l, _len3, _results1;
              _results1 = [];
              for (_l = 0, _len3 = orig_line_nodes.length; _l < _len3; _l++) {
                node = orig_line_nodes[_l];
                node = this.nodes[nodes.indexOf(node)];
                node.lines.push(line);
                _results1.push(node);
              }
              return _results1;
            }).call(this);
            _results.push(line);
          }
          return _results;
        }).call(this);
        _ref = this.lines;
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          line = _ref[_k];
          source = line.nodes[0];
          _ref1 = line.nodes.slice(1);
          for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
            target = _ref1[_l];
            edge = new Edge({
              source: source,
              target: target,
              line: line
            });
            source.edges.push(edge);
            target.edges.push(edge);
            this.edges.push(edge);
            line.edges.push(edge);
            source = target;
          }
        }
        _ref2 = this.nodes;
        for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
          node = _ref2[_m];
          this.nodesById[node.id] = node;
          if (node.edges.length > 10) {
            P("node with many edges", node);
          }
        }
      }

      Graph.prototype.centralNode = function() {
        var n, ns;
        ns = (function() {
          var _i, _len, _ref, _results;
          _ref = this.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            if (n.kind === 'central_node') {
              _results.push(n);
            }
          }
          return _results;
        }).call(this);
        if (ns.length === 0) {
          throw "no central ndoe";
        }
        if (ns.length > 1) {
          throw "more than one central node";
        }
        return ns[0];
      };

      Graph.prototype.kanjis = function() {
        var node, _i, _len, _ref, _results;
        _ref = this.nodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          if (node.data.kanji) {
            _results.push(node.data);
          }
        }
        return _results;
      };

      Graph.prototype.radicals = function() {
        var line, _i, _len, _ref, _results;
        _ref = this.lines;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _results.push(line.data);
        }
        return _results;
      };

      Graph.prototype.toPlainLines = function() {
        var data, id, kind, line, lines, node, nodes, plain_line, x, y, _i, _len, _ref;
        nodes = {};
        _ref = this.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          x = node.x, y = node.y, data = node.data, id = node.id, kind = node.kind;
          nodes[node.id] = {
            x: x,
            y: y,
            data: data,
            id: id,
            kind: kind
          };
        }
        lines = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.lines;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            line = _ref1[_j];
            plain_line = (function() {
              var _k, _len2, _ref2, _results1;
              _ref2 = line.nodes;
              _results1 = [];
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                node = _ref2[_k];
                _results1.push(nodes[node.id]);
              }
              return _results1;
            })();
            data = line.data, id = line.id;
            plain_line.obj = {
              data: data,
              id: id
            };
            _results.push(plain_line);
          }
          return _results;
        }).call(this);
        return lines;
      };

      Graph.prototype.ruleViolations = function() {
        var node;
        return d3.sum((function() {
          var _i, _len, _ref, _results;
          _ref = this.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            if (node.kind === 'hi_node') {
              _results.push(node.ruleViolations(this));
            }
          }
          return _results;
        }).call(this));
      };

      Graph.prototype.critQuality = function() {
        var node;
        return Math.ceil(d3.sum([
          d3.sum((function() {
            var _i, _len, _ref, _results;
            _ref = this.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              if (node.kind === 'hi_node') {
                _results.push(node.critQuality(this));
              }
            }
            return _results;
          }).call(this)), criteria.lengthOfEdges(this.edges)
        ]));
      };

      return Graph;

    })();
    Cluster = (function() {
      function Cluster(nodes) {
        var n;
        this.nodes = nodes;
        this.copies = (function() {
          var _i, _len, _ref, _results;
          _ref = this.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            _results.push([n.x, n.y]);
          }
          return _results;
        }).call(this);
      }

      Cluster.prototype.ruleViolations = function(graph) {
        return this._ruleViolations != null ? this._ruleViolations : this._ruleViolations = (function() {
          var n;
          if (!(graph instanceof Graph)) {
            throw "graph not a Graph";
          }
          return d3.sum((function() {
            var _i, _len, _ref, _results;
            _ref = this.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              _results.push(n.ruleViolations(graph));
            }
            return _results;
          }).call(this));
        })();
      };

      Cluster.prototype.critQuality = function(graph) {
        return this._critQuality != null ? this._critQuality : this._critQuality = (function() {
          var n;
          if (!(graph instanceof Graph)) {
            throw "graph not a Graph";
          }
          return d3.sum((function() {
            var _i, _len, _ref, _results;
            _ref = this.nodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              _results.push(n.critQuality(graph));
            }
            return _results;
          }).call(this));
        })();
      };

      Cluster.prototype.moveBy = function(x, y) {
        var n, _i, _len, _ref, _results;
        this._ruleViolations = this._critQuality = void 0;
        _ref = this.nodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          _results.push(n.moveBy(x, y));
        }
        return _results;
      };

      Cluster.prototype.resetPosition = function() {
        var i, n, x, y, _i, _len, _ref, _ref1, _results;
        this._ruleViolations = this._critQuality = void 0;
        _ref = this.nodes;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          n = _ref[i];
          _ref1 = this.copies[i], x = _ref1[0], y = _ref1[1];
          _results.push(n.move(x, y));
        }
        return _results;
      };

      return Cluster;

    })();
    return my.graph = {
      Node: Node,
      Edge: Edge,
      Line: Line,
      Graph: Graph,
      Cluster: Cluster
    };
  });

}).call(this);

//# sourceMappingURL=graph.js.map
