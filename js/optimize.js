// Generated by CoffeeScript 1.6.2
(function() {
  var __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  self.require = {
    urlArgs: "bust=" + (new Date()).getTime()
  };

  importScripts('/lib/require.js');

  self.document = {
    documentElement: function() {}
  };

  self.window = self;

  window.CSSStyleDeclaration = function() {};

  importScripts('/lib/d3.v3.js');

  self.console = {
    log: function() {
      var xs;

      xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return postMessage({
        type: 'log',
        log: xs.join(' ')
      });
    }
  };

  console.debug = console.info = console.log;

  self.my = {
    debug: true
  };

  importScripts('config.js');

  require({
    baseUrl: './'
  }, ['utils', 'grid', 'graph'], function(utils, grid, _arg) {
    var Cluster, Edge, Graph, Grid, GridCoordGenerator, Line, Node, P, handler, toOptimize;

    Cluster = _arg.Cluster, Node = _arg.Node, Edge = _arg.Edge, Line = _arg.Line, Graph = _arg.Graph;
    P = utils.P;
    Grid = grid.Grid, GridCoordGenerator = grid.GridCoordGenerator;
    addEventListener('message', function(ev) {
      console.log('worker receive', ev.data.type);
      return handler[ev.data.type](ev.data);
    });
    handler = {
      my_graph: null,
      grid: null,
      graph: function(_arg1) {
        var graph, node, _i, _len, _ref, _results;

        graph = _arg1.graph;
        this.my_graph = graph = new Graph(graph);
        this.grid = new Grid;
        _ref = graph.nodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          _results.push(this.grid.set(node, node));
        }
        return _results;
      },
      snapNodes: function() {
        var b, coord, d, graph, i, list, node, nodes, old_length, toMove, x, y, _i, _len, _name, _ref, _ref1, _ref2, _ref3, _ref4;

        graph = this.my_graph;
        grid = this.grid;
        nodes = graph.nodes.slice(0);
        old_length = nodes.length;
        while (nodes.length > 0) {
          toMove = {};
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            node = nodes[_i];
            if (!toOptimize(node)) {
              continue;
            }
            _ref = this.nearestFreeGrid(node, grid), x = _ref[0], y = _ref[1];
            ((_ref1 = toMove[_name = x + "x" + y]) != null ? _ref1 : toMove[_name] = []).push(node);
          }
          nodes = [];
          for (coord in toMove) {
            list = toMove[coord];
            _ref2 = (function() {
              var _j, _len1, _ref2, _results;

              _ref2 = coord.split('x');
              _results = [];
              for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                d = _ref2[_j];
                _results.push(+d);
              }
              return _results;
            })(), x = _ref2[0], y = _ref2[1];
            _ref3 = utils.nearestXY({
              x: x,
              y: y
            }, list), b = _ref3.b, i = _ref3.i;
            grid.remove(b);
            grid.set([x, y], b);
            [].splice.apply(list, [i, i - i + 1].concat(_ref4 = [])), _ref4;
            nodes = __slice.call(nodes).concat(__slice.call(list));
          }
          if (nodes.length >= old_length) {
            throw "no progress";
          }
          old_length = nodes.length;
        }
        return this.postNodes(nodes);
      },
      postNodes: function(nodes) {
        var node;

        nodes = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            node = nodes[_i];
            _results.push({
              x: node.x,
              y: node.y,
              id: node.id,
              debug_fill: node.style.debug_fill
            });
          }
          return _results;
        })();
        return postMessage({
          type: 'nodes',
          nodes: nodes
        });
      },
      applyRules: function() {
        var before, changed_nodes, edges, n, no_move_since, nodes, optimizeNode, postNodes, queue, _ref,
          _this = this;

        _ref = this.my_graph, nodes = _ref.nodes, edges = _ref.edges;
        queue = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            n = nodes[_i];
            if (toOptimize(n)) {
              _results.push(n);
            }
          }
          return _results;
        })();
        no_move_since = [0];
        changed_nodes = [];
        before = this.my_graph.ruleViolations();
        (postNodes = function() {
          if (changed_nodes.length) {
            _this.postNodes(changed_nodes);
            while (changed_nodes.length) {
              changed_nodes.pop();
            }
          }
          if (no_move_since < queue.length * 2) {
            return setTimeout(postNodes, config.transitionTime);
          }
        })();
        return (optimizeNode = function() {
          var moved, node, now, _i;

          for (_i = 1; _i <= 10; _i++) {
            if (!(no_move_since[0]++ < queue.length * 2)) {
              now = _this.my_graph.ruleViolations();
              P('optimization done. ruleViolations from', before, 'to', now);
              return;
            }
            node = queue.shift();
            moved = _this.moveNode(node);
            if (moved) {
              no_move_since[0] = 0;
              changed_nodes.push(node);
            }
            queue.push(node);
          }
          return setTimeout(optimizeNode, 100);
        })();
      },
      optimizeNodes: function(nodes) {
        var graph, moved, node, quality, _i, _len;

        P('optimize', nodes.length, 'nodes');
        graph = this.my_graph;
        quality = function(node) {
          return node.critValue(graph);
        };
        moved = [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          if (node.critValue(graph) === 0) {
            continue;
          }
          if (this.moveNode(node, quality)) {
            moved.push(node);
          }
        }
        P(moved.length, 'movements');
        return this.postNodes(moved);
      },
      optimizeStraightLineClusters: function(cb) {
        var cluster, clusters, foo, node, nodes, used,
          _this = this;

        nodes = this.my_graph.nodes;
        used = {};
        clusters = (function() {
          var _i, _j, _len, _len1, _ref, _results;

          _results = [];
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            node = nodes[_i];
            if (!toOptimize(node)) {
              continue;
            }
            if (node.id in used) {
              continue;
            }
            cluster = this.straightLineCluster(node);
            if (!cluster) {
              continue;
            }
            _ref = cluster.nodes;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              node = _ref[_j];
              if (node.id in used) {
                cluster = null;
              }
              used[node.id] = true;
            }
            if (!cluster) {
              continue;
            }
            _results.push(cluster);
          }
          return _results;
        }).call(this);
        clusters.sort(function(a, b) {
          return d3.descending(a.critValue(_this.my_graph), b.critValue(_this.my_graph));
        });
        return (foo = function() {
          var moved;

          if (!clusters.length) {
            return typeof cb === "function" ? cb() : void 0;
          }
          cluster = clusters.shift();
          if (cluster.critValue(_this.my_graph) > 0) {
            moved = _this.moveCluster(cluster);
            if (!moved) {
              _this.optimizeNodes(cluster.nodes);
            }
          }
          return setTimeout(foo, 10);
        })();
      },
      moveCluster: function(cluster) {
        var coord, graph, min, _i, _len, _ref, _ref1;

        graph = this.my_graph;
        min = {
          coord: [0, 0],
          value: cluster.critValue(graph)
        };
        _ref = this.coordsForClusterMovement();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          coord = _ref[_i];
          cluster.moveBy.apply(cluster, coord);
          if (cluster.critValue(graph) < min.value) {
            min.coord = coord;
            min.value = cluster.critValue(graph);
          }
          cluster.resetPosition();
        }
        if (!((min.coord[0] === (_ref1 = min.coord[1]) && _ref1 === 0))) {
          cluster.moveBy.apply(cluster, min.coord);
          this.postNodes(cluster.nodes);
          return true;
        } else {
          return false;
        }
      },
      moveNode: function(node) {
        var before, coord, coords, copy, gt, min, perfect, quality, value, x, y, _i, _len, _ref,
          _this = this;

        copy = {
          x: node.x,
          y: node.y
        };
        coords = this.coordsAroundNode(node, 8);
        quality = function() {
          return {
            rule: _this.my_graph.ruleViolations(),
            crit: _this.my_graph.critQuality()
          };
        };
        gt = function(a, b) {
          return a.rule > b.rule || (a.rule === b.rule && a.crit > b.crit);
        };
        perfect = function(x) {
          var _ref;

          return (x.rule === (_ref = x.crit) && _ref === 0);
        };
        before = quality();
        min = {
          value: before,
          coord: [node.x, node.y]
        };
        for (_i = 0, _len = coords.length; _i < _len; _i++) {
          coord = coords[_i];
          node.move.apply(node, coord);
          value = quality();
          if (gt(min.value, value)) {
            min.value = value;
            min.coord = coord;
            if (perfect(min.value)) {
              break;
            }
          }
        }
        _ref = min.coord, x = _ref[0], y = _ref[1];
        if (x !== copy.x || y !== copy.y) {
          node.move(x, y);
          this.grid.remove(copy);
          this.grid.set(node, node);
          return node;
        } else {
          node.move(copy.x, copy.y);
          return null;
        }
      },
      coordsAroundNode: function(node, n) {
        var coords, generator,
          _this = this;

        generator = new GridCoordGenerator({
          x: node.x,
          y: node.y,
          spacing: config.gridSpacing,
          filter: function(coord) {
            return !_this.grid.has(coord);
          }
        });
        coords = [];
        while (coords.length < n) {
          coords = __slice.call(coords).concat(__slice.call(generator.next()));
        }
        return coords;
      },
      coordsForClusterMovement: (function() {
        var coords, generator;

        generator = new GridCoordGenerator({
          spacing: config.gridSpacing
        });
        coords = d3.merge((function() {
          var _i, _results;

          _results = [];
          for (_i = 1; _i <= 20; _i++) {
            _results.push(generator.next());
          }
          return _results;
        })());
        return function() {
          return coords;
        };
      })(),
      nearestFreeGrid: function(_arg1, grid) {
        var b, coord, coords, g, generator, x, y;

        x = _arg1.x, y = _arg1.y;
        g = config.gridSpacing;
        generator = new GridCoordGenerator({
          x: x,
          y: y,
          spacing: g,
          filter: function(coord) {
            return !grid.has(coord);
          }
        });
        coord = [g * Math.round(x / g), g * Math.round(y / g)];
        coords = generator.next();
        if (!grid.has(coord)) {
          coords.push(coord);
        }
        b = utils.nearest01([x, y], coords).b;
        return b;
      },
      straightNode: function(node) {
        var edge, okay, other_edge, _i, _len, _ref;

        okay = false;
        _ref = node.edges;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          other_edge = edge.otherEdge(node.edges);
          if (!other_edge) {
            continue;
          }
          if ((edge.getAngle(other_edge)) !== 0) {
            return false;
          }
          okay = true;
        }
        return okay;
      },
      straightLineCluster: function(start) {
        var cluster, n, next, node, queue, _i, _len, _ref;

        if (!this.straightNode(start)) {
          _ref = start.nextNodes();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            start = _ref[_i];
            if (!toOptimize(start)) {
              continue;
            }
            if (this.straightNode(start)) {
              break;
            }
          }
        }
        cluster = [start];
        queue = [start];
        while (queue.length) {
          node = queue.pop();
          if (this.straightNode(node)) {
            next = (function() {
              var _j, _len1, _ref1, _results;

              _ref1 = node.nextNodes();
              _results = [];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                n = _ref1[_j];
                if (__indexOf.call(cluster, n) < 0 && toOptimize(n)) {
                  _results.push(n);
                }
              }
              return _results;
            })();
            cluster.push.apply(cluster, next);
            queue.push.apply(queue, next);
          }
        }
        cluster;
        return new Cluster(cluster);
      }
    };
    toOptimize = function(node) {
      return node.kind === 'hi_node';
    };
    return postMessage('ready');
  });

}).call(this);

/*
//@ sourceMappingURL=optimize.map
*/
