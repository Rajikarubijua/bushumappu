// Generated by CoffeeScript 1.6.2
(function() {
  var config;

  config = {
    showLines: false,
    fixedEndstation: false,
    fixedStation: false,
    filterRadicals: function(radicals) {
      return radicals.slice(0, 14);
    },
    filterLinkedRadicals: function(radicals) {
      return radicals;
    },
    sunflowerKanjis: true,
    kmeansInitialVectorsRandom: false,
    kmeansClustersN: -1,
    forceGraph: false,
    circularLines: false,
    gridSpacing: 48,
    debugOverlay: false,
    transitionTime: 750 * 2,
    initialScale: 0.06,
    edgesBeforeSnap: false,
    timeToOptimize: 3000,
    optimizeMaxLoops: 3,
    optimizeMaxSteps: 1
  };

  figue.KMEANS_MAX_ITERATIONS = 1;

  window.my = {
    kanjis: {},
    radicals: {},
    jouyou_radicals: {},
    jouyou: [],
    jouyou_grade: {},
    config: config
  };

  define(['utils', 'load_data', 'prepare_data', 'initial_embedding', 'interactivity', 'routing', 'test_routing'], function(_arg, loadData, prepare, _arg1, _arg2, _arg3, testRouting) {
    var Embedder, MetroMapLayout, P, View, async, main, prettyDebug, showDebugOverlay, somePrettyPrint, styleZoom;

    P = _arg.P, somePrettyPrint = _arg.somePrettyPrint, styleZoom = _arg.styleZoom, async = _arg.async, prettyDebug = _arg.prettyDebug;
    Embedder = _arg1.Embedder;
    View = _arg2.View;
    MetroMapLayout = _arg3.MetroMapLayout;
    main = function() {
      var body, draggingEnd, draggingStart, embedder, generateEdges, graph, h, layout, optimize_loop, svg, view, w, zoom;

      body = my.body = d3.select('body');
      if (config.debugOverlay) {
        showDebugOverlay(body);
      }
      svg = my.svg = body.append('svg');
      svg.g = svg.append('g');
      w = new Signal;
      h = new Signal;
      window.onresize = function() {
        w(window.innerWidth);
        return h(window.innerHeight);
      };
      window.onresize();
      new Observer(function() {
        var attrs;

        attrs = {
          width: w(),
          height: h()
        };
        svg.attr(attrs);
        return svg.style(attrs);
      });
      svg.call((zoom = d3.behavior.zoom()).translate([w() / 2, h() / 2]).scale(config.initialScale).on('zoom', styleZoom(svg.g, zoom)));
      draggingStart = function() {
        return svg.classed('dragging', true);
      };
      draggingEnd = function() {
        return svg.classed('dragging', false);
      };
      svg.on('mousedown.cursor', draggingStart);
      svg.on('mouseup.cursor', draggingEnd);
      svg.on('touchstart.cursor', draggingStart);
      svg.on('touchend.cursor', draggingEnd);
      embedder = new Embedder({
        config: config
      });
      embedder.setup();
      generateEdges = function() {
        console.info('generate edges...');
        embedder.generateEdges();
        return console.info('generate edges done');
      };
      if (config.edgesBeforeSnap) {
        generateEdges();
      }
      graph = embedder.graph;
      view = new View({
        svg: svg.g,
        graph: graph,
        config: config
      });
      layout = new MetroMapLayout({
        config: config,
        graph: graph
      });
      view.update();
      async.seqTimeout(config.transitionTime, config.gridSpacing > 0 && (function() {
        console.info('snap nodes...');
        layout.snapNodes();
        console.info('snap node done');
        if (!config.edgesBeforeSnap) {
          generateEdges();
        }
        return view.update();
      }), (function() {
        return optimize_loop();
      }));
      optimize_loop = function() {
        var stats;

        console.info('optimize...');
        stats = layout.optimize().stats;
        console.info('optimize done', prettyDebug(stats));
        view.update();
        if ((config.optimizeMaxLoops === -1) || (++optimize_loop.loops < config.optimizeMaxLoops)) {
          return setTimeout(optimize_loop, config.transitionTime);
        }
      };
      return optimize_loop.loops = 0;
    };
    showDebugOverlay = function(el) {
      return el.append('pre').attr({
        id: 'my'
      }).text(somePrettyPrint(my));
    };
    testRouting.runTests([]);
    console.info('end of tests');
    return loadData(main);
  });

}).call(this);

/*
//@ sourceMappingURL=main.map
*/
