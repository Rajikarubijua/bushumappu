// Generated by CoffeeScript 1.6.2
(function() {
  var __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(["utils", "prepare_data", 'graph'], function(_arg, prepare, _arg1) {
    var Edge, Embedder, Line, Node, P, arrayUnique, equidistantSelection, getClusterN, getEdges, getKanjisForRadicalInCluster, getMinMax, getNodePosition, length, max, nearestXY, setupClusterPosition, setupClustersForRadicals, setupPositions, sunflower;

    P = _arg.P, length = _arg.length, arrayUnique = _arg.arrayUnique, equidistantSelection = _arg.equidistantSelection, max = _arg.max, sunflower = _arg.sunflower, getMinMax = _arg.getMinMax, nearestXY = _arg.nearestXY;
    Node = _arg1.Node, Edge = _arg1.Edge, Line = _arg1.Line;
    Embedder = (function() {
      function Embedder(_arg2) {
        this.config = _arg2.config;
        this.graph = {};
        this.radicals = [];
      }

      Embedder.prototype.setup = function() {
        var clusters, clusters_n, config, d, data, edges, endnodes, initial_vectors, k, kanjis, lines, n, node, nodes, nodes_kanjis, nodes_radicals, r, radicals, radicals_n, vectors;

        config = this.config;
        d = 2 * config.nodeSize;
        prepare.setupRadicalJouyous();
        prepare.setupKanjiGrades();
        radicals = prepare.getRadicals();
        radicals_n = length(radicals);
        kanjis = prepare.getKanjis(radicals);
        nodes = (function() {
          var _i, _len, _ref, _results;

          _ref = __slice.call(kanjis).concat(__slice.call(radicals));
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            data = _ref[_i];
            node = new Node({
              data: data
            });
            node.vector = prepare.getRadicalVector(data, radicals);
            node.label = data.kanji || data.radical;
            node.cluster = null;
            node.fixed = +config.fixednode;
            data.node = node;
            _results.push(node);
          }
          return _results;
        })();
        nodes_kanjis = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = kanjis.length; _i < _len; _i++) {
            k = kanjis[_i];
            _results.push(k.node);
          }
          return _results;
        })();
        nodes_radicals = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = radicals.length; _i < _len; _i++) {
            r = radicals[_i];
            _results.push(r.node);
          }
          return _results;
        })();
        vectors = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = nodes_kanjis.length; _i < _len; _i++) {
            n = nodes_kanjis[_i];
            _results.push(n.vector);
          }
          return _results;
        })();
        clusters_n = getClusterN(vectors, config);
        if (!config.kmeansInitialVectorsRandom) {
          initial_vectors = equidistantSelection(clusters_n, vectors);
        }
        console.time('prepare.setupClusterAssignment');
        clusters = prepare.setupClusterAssignment(nodes_kanjis, initial_vectors, clusters_n);
        console.timeEnd('prepare.setupClusterAssignment');
        setupClustersForRadicals(radicals, clusters);
        setupPositions(clusters, d, config);
        edges = [];
        lines = [];
        endnodes = nodes_radicals;
        this.radicals = radicals;
        return this.graph = {
          nodes: nodes_kanjis,
          endnodes: endnodes,
          edges: edges,
          lines: lines,
          kanjis: kanjis
        };
      };

      Embedder.prototype.generateEdges = function() {
        var config, edges, graph, lines, radicals, _ref;

        radicals = this.radicals, graph = this.graph, config = this.config;
        radicals = config.filterLinkedRadicals(radicals);
        _ref = getEdges(radicals, config), edges = _ref[0], lines = _ref[1];
        graph.edges = edges;
        return graph.lines = lines;
      };

      return Embedder;

    })();
    getEdges = function(radicals, _arg2) {
      var a, b, circularLines, edge, edges, i, kanji, l, line, lines, nodes, radical, _i, _len, _ref, _ref1;

      circularLines = _arg2.circularLines;
      edges = [];
      lines = [];
      for (_i = 0, _len = radicals.length; _i < _len; _i++) {
        radical = radicals[_i];
        lines.push(line = new Line({
          data: radical
        }));
        nodes = (function() {
          var _j, _len1, _ref, _results;

          _ref = radical.jouyou;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            kanji = _ref[_j];
            _results.push(kanji.node);
          }
          return _results;
        })();
        a = radical.node;
        l = nodes.length;
        while (nodes.length > 0) {
          _ref = nearestXY(a, nodes), b = _ref.b, i = _ref.i;
          [].splice.apply(nodes, [i, i - i + 1].concat(_ref1 = [])), _ref1;
          edge = new Edge({
            source: a,
            target: b,
            line: line
          });
          edges.push(edge);
          a.edges.push(edge);
          b.edges.push(edge);
          line.edges.push(edge);
          line.nodes.push(a);
          a.lines.push(line);
          a = b;
          if (nodes.length === l) {
            throw "no progres";
          }
          l = nodes.length;
        }
        if (circularLines) {
          b = radical.node;
          edge = new Edge({
            source: a,
            target: b,
            line: line
          });
          edges.push(edge);
          a.edges.push(edge);
          b.edges.push(edge);
          line.edges.push(edge);
          line.nodes.push(a);
          a.lines.push(line);
        }
        line.nodes.push(b);
        b.lines.push(line);
      }
      return [edges, lines];
    };
    setupPositions = function(clusters, d, config) {
      var cluster, i, node, x, y, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;

      for (_i = 0, _len = clusters.length; _i < _len; _i++) {
        cluster = clusters[_i];
        _ref = cluster.nodes;
        for (i = _j = 0, _len1 = _ref.length; _j < _len1; i = ++_j) {
          node = _ref[i];
          _ref1 = getNodePosition(node, i, d, cluster.nodes.length, config), x = _ref1.x, y = _ref1.y;
          node.x = x;
          node.y = y;
        }
      }
      setupClusterPosition(clusters, d);
      _results = [];
      for (_k = 0, _len2 = clusters.length; _k < _len2; _k++) {
        cluster = clusters[_k];
        _results.push((function() {
          var _l, _len3, _ref2, _results1;

          _ref2 = cluster.nodes;
          _results1 = [];
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            node = _ref2[_l];
            node.x += cluster.x;
            _results1.push(node.y += cluster.y);
          }
          return _results1;
        })());
      }
      return _results;
    };
    getClusterN = function(vectors, _arg2) {
      var kmeansClustersN;

      kmeansClustersN = _arg2.kmeansClustersN;
      return Math.min(vectors.length, (function() {
        if (kmeansClustersN > 0) {
          return kmeansClustersN;
        } else {
          switch (kmeansClustersN) {
            case -1:
              return Math.floor(vectors[0].length);
            case 0:
              return Math.floor(Math.sqrt(vectors.length / 2));
          }
        }
      })());
    };
    getKanjisForRadicalInCluster = function(radical, cluster) {
      var kanjis, node;

      return kanjis = (function() {
        var _i, _len, _ref, _ref1, _results;

        _ref = cluster.nodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          if (node.data.kanji && (_ref1 = radical.radical, __indexOf.call(node.data.radicals, _ref1) >= 0)) {
            _results.push(node.data);
          }
        }
        return _results;
      })();
    };
    setupClustersForRadicals = function(radicals, clusters) {
      var cluster, radical, _i, _len, _results;

      _results = [];
      for (_i = 0, _len = radicals.length; _i < _len; _i++) {
        radical = radicals[_i];
        cluster = max(clusters, function(cluster) {
          return length(getKanjisForRadicalInCluster(radical, cluster));
        });
        radical.node.cluster = cluster;
        _results.push(cluster.nodes.push(radical.node));
      }
      return _results;
    };
    setupClusterPosition = function(clusters, d) {
      var cluster, dx, dy, i, minmax, r, x, y, _i, _j, _len, _len1, _ref, _results;

      for (_i = 0, _len = clusters.length; _i < _len; _i++) {
        cluster = clusters[_i];
        minmax = getMinMax(cluster.nodes, {
          "x": "x",
          "y": "y"
        });
        dx = minmax.max_x.x - minmax.min_x.x;
        dy = minmax.max_y.y - minmax.min_y.y;
        cluster.r = 0.5 * Math.max(dx, dy);
      }
      minmax = getMinMax(clusters, {
        "r": "r"
      });
      r = minmax.max_r.r;
      _results = [];
      for (i = _j = 0, _len1 = clusters.length; _j < _len1; i = ++_j) {
        cluster = clusters[i];
        _ref = sunflower({
          index: i + 1,
          factor: r
        }), x = _ref.x, y = _ref.y;
        cluster.x = x;
        _results.push(cluster.y = y);
      }
      return _results;
    };
    getNodePosition = function(node, index, d, n, _arg2) {
      var cluster_index, columns, sunflowerKanjis, x, y, _ref;

      sunflowerKanjis = _arg2.sunflowerKanjis;
      x = y = 0;
      cluster_index = node.cluster.nodes.indexOf(node);
      if (sunflowerKanjis) {
        _ref = sunflower({
          index: cluster_index + 1,
          factor: 2.7 * d
        }), x = _ref.x, y = _ref.y;
      } else {
        columns = Math.floor(Math.sqrt(n));
        x = 2 * d * (index % columns);
        y = 2 * d * Math.floor(index / columns);
      }
      return {
        x: x,
        y: y
      };
    };
    return {
      Embedder: Embedder
    };
  });

}).call(this);

/*
//@ sourceMappingURL=initial_embedding.map
*/
