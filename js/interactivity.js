// Generated by CoffeeScript 1.6.2
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['utils', 'tubeEdges', 'filtersearch', 'history', 'central_station', 'graph', 'detail_table', 'station_label', 'optimizer_client'], function(utils, _arg, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7) {
    var CentralStationEmbedder, DetailTable, FilterSearch, History, Node, Optimizer, P, StationLabel, Tube, View, clearFuncTimer, colors, compareNumber, createTubes, delayDblClick, endnodeSelectLine, setFuncTimer, styleZoom, svgline, svgline01;

    Tube = _arg.Tube, createTubes = _arg.createTubes;
    FilterSearch = _arg1.FilterSearch;
    History = _arg2.History;
    CentralStationEmbedder = _arg3.CentralStationEmbedder;
    Node = _arg4.Node;
    DetailTable = _arg5.DetailTable;
    StationLabel = _arg6.StationLabel;
    Optimizer = _arg7.Optimizer;
    P = utils.P, compareNumber = utils.compareNumber, styleZoom = utils.styleZoom;
    colors = ["#E53517", "#008BD0", "#97BE0D", "#641F80", "#F07C0D", "#2FA199", "#FFCC00", "#E2007A", "#290E03"];
    View = (function() {
      function View(_arg8) {
        var h, svg, w;

        svg = _arg8.svg, this.config = _arg8.config, this.kanjis = _arg8.kanjis, this.radicals = _arg8.radicals;
        this.toggleMenu = __bind(this.toggleMenu, this);
        this.removeKanjiDetail = __bind(this.removeKanjiDetail, this);
        this.addKanjiDetail = __bind(this.addKanjiDetail, this);
        this.addStationLabel = __bind(this.addStationLabel, this);
        this.autoFocus = __bind(this.autoFocus, this);
        this.svg = svg.g;
        this.parent = svg;
        this.g_edges = this.svg.append('g').attr({
          'id': 'edge_'
        });
        this.g_nodes = this.svg.append('g').attr({
          'id': 'node_'
        });
        this.g_endnodes = this.svg.append('g').attr({
          'id': 'ednnode_'
        });
        this.g_stationLabels = this.svg.append('g').attr({
          'id': 'stationLabel_'
        });
        this.zoom = d3.behavior.zoom();
        this.history = new History({});
        this.detailTable = new DetailTable({});
        this.history.setup(this);
        this.embedder = new CentralStationEmbedder({
          config: this.config
        });
        this.seaFill = new FilterSearch({});
        w = new Signal;
        h = new Signal;
        window.onresize = function() {
          w(window.innerWidth);
          return h(window.innerHeight);
        };
        window.onresize();
        new Observer(function() {
          var attrs;

          attrs = {
            width: 0.95 * w(),
            height: 0.98 * h()
          };
          svg.attr(attrs);
          return svg.style(attrs);
        });
        svg.call(this.zoom.translate([w() / 2, h() / 2]).scale(this.config.initialScale).on('zoom', styleZoom(svg.g, this.zoom)));
        svg.on('dblclick.zoom', null);
      }

      View.prototype.autoFocus = function(kanji) {
        var focus, node, transX, transY, transform, viewport, _i, _len, _ref;

        focus = {};
        _ref = this.graph.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          node.style.isFocused = false;
          if (node.data.kanji === kanji) {
            node.style.isFocused = true;
            focus = node;
          }
        }
        if (focus === {} || kanji === void 0) {
          P('nothing to focus here');
          return;
        }
        viewport = d3.select('#graph')[0][0];
        transX = (viewport.attributes[1].value / 2) - focus.x * this.zoom.scale();
        transY = (viewport.attributes[2].value / 2) - focus.y * this.zoom.scale();
        transform = "-webkit-transform: translate(" + transX + "px, " + transY + "px) scale(" + (this.zoom.scale()) + ")";
        d3.select('#graph g').transition().attr('style', transform);
        this.parent.call(this.zoom.translate([transX, transY]).on('zoom', styleZoom(this.svg, this.zoom, true)));
        this.parent.on('dblclick.zoom', null);
        return this.update();
      };

      View.prototype.changeToCentral = function(kanji) {
        var graph, _ref,
          _this = this;

        if (kanji === this.history.getCurrentCentral()) {
          return;
        }
        d3.selectAll('.station-label').remove();
        P("changeToCentral " + kanji.kanji);
        this.history.addCentral(kanji.kanji);
        graph = this.embedder.graph(kanji, this.radicals, this.kanjis);
        if ((_ref = this.optimizer) != null) {
          _ref.worker.terminate();
        }
        if (config.optimizer) {
          this.optimizer = new Optimizer(function() {
            _this.optimizer.onNodes = function() {
              return _this.update(graph);
            };
            _this.optimizer.graph(graph);
            _this.optimizer.snapNodes();
            return _this.optimizer.applyRules();
          });
        } else {
          this.update(graph);
        }
        return this.seaFill.setup(this, false);
      };

      View.prototype.changeToCentralFromNode = function(node) {
        return this.changeToCentral(node.data);
      };

      View.prototype.changeToCentralFromStr = function(strKanji) {
        var central;

        strKanji = strKanji.trim();
        central = my.kanjis[strKanji];
        if (central == null) {
          throw "central undefined";
        }
        return this.changeToCentral(central);
      };

      View.prototype.doInitial = function() {
        return this.seaFill.setup(this, true);
      };

      View.prototype.doSlideshow = function() {
        var me, slideshow;

        d3.select('#overlay').remove();
        me = this;
        return (slideshow = function() {
          var i, kanji, _ref;

          if ((_ref = slideshow.steps) == null) {
            slideshow.steps = 0;
          }
          if (slideshow.steps++ >= me.config.slideshowSteps) {
            return;
          }
          i = Math.floor(Math.random() * me.kanjis.length);
          kanji = me.kanjis[i];
          if (slideshow.steps === 1) {
            kanji = my.kanjis[config.debugKanji];
          }
          me.changeToCentral(kanji);
          return setTimeout(slideshow, me.config.transitionTime + 2000);
        })();
      };

      View.prototype.addStationLabel = function(node) {
        var label;

        label = new StationLabel({
          node: node,
          g_stationLabels: this.g_stationLabels
        });
        return label.showStationLabel(node);
      };

      View.prototype.enterNodes = function(enter) {
        var addKanjiDetail, addStationLabel, g_node, g_station_kanji, height, width, x, y,
          _this = this;

        addStationLabel = this.addStationLabel, addKanjiDetail = this.addKanjiDetail;
        g_node = enter.append('g').classed('node', true);
        g_station_kanji = g_node.append('g').classed('station-kanji', true).on('mouseenter.delayed-hover', function(node) {
          return setFuncTimer(this, 800, function() {
            return addStationLabel(node);
          });
        }).on('mouseleave.delayed-hover', function(node) {
          return clearFuncTimer(this);
        }).on('click.addKanjiDetail', function(node) {
          return delayDblClick(550, function() {
            return addKanjiDetail(node);
          });
        }).on('dblclick.changeToCentralFromNode', function(node) {
          return _this.changeToCentralFromNode(node);
        });
        x = y = -config.nodeSize;
        width = height = 2 * config.nodeSize;
        g_station_kanji.append('rect').attr({
          x: x,
          y: y,
          width: width,
          height: height
        });
        return g_station_kanji.append('text');
      };

      View.prototype.exitNodes = function(exit) {
        return exit.remove();
      };

      View.prototype.updateNodes = function(graph) {
        var n, nodes, update;

        nodes = (function() {
          var _i, _len, _ref, _ref1, _results;

          _ref = graph.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            if ((_ref1 = n.kind) === 'hi_node' || _ref1 === 'lo_node') {
              _results.push(n);
            }
          }
          return _results;
        })();
        update = this.g_nodes.selectAll('g.node').data(nodes, function(node) {
          return node.key();
        });
        this.enterNodes(update.enter());
        this.exitNodes(update.exit());
        update.attr('id', function(node) {
          return "kanji_" + node.data.kanji;
        }).classed("filtered", function(node) {
          return node.style.filtered;
        }).classed("searchresult", function(node) {
          return node.style.isSearchresult;
        }).classed("focused", function(node) {
          return node.style.isFocused;
        }).style({
          fill: function(node) {
            return node.style.debug_fill || null;
          }
        }).select('text').text(function(node) {
          return node.label();
        });
        return update.transition().duration(config.transitionTime).attr({
          transform: function(node) {
            return utils.cssTranslateXY(node);
          }
        });
      };

      View.prototype.addKanjiDetail = function(node) {
        var _this = this;

        this.detailTable.addKanji(node.data);
        this.toggleMenu(true);
        return d3.selectAll('#details td.content').on('click.hightlightSelected', function(node) {
          return _this.autoFocus(node);
        });
      };

      View.prototype.removeKanjiDetail = function(node) {
        var _this = this;

        this.detailTable.removeKanji(node.data);
        d3.event.stopPropagation();
        return d3.selectAll('#details td.content').on('click.hightlightSelected', function(node) {
          return _this.autoFocus(node);
        });
      };

      View.prototype.toggleMenu = function(shouldStayOpen) {
        var arrow, bar, toggleBtn;

        if (shouldStayOpen == null) {
          shouldStayOpen = false;
        }
        bar = d3.select('#bottomBar');
        toggleBtn = d3.select('#toggle-bottom-bar');
        arrow = toggleBtn.select('.arrowIcon');
        if (bar.node().clientHeight > 11 && !shouldStayOpen) {
          bar.style('max-height', '10px');
          arrow.classed('up', true);
          return arrow.classed('down', false);
        } else {
          bar.style('max-height', '250px');
          arrow.classed('down', true);
          return arrow.classed('up', false);
        }
      };

      View.prototype.enterEdges = function(enter) {
        var g_edge;

        g_edge = enter.append('g').classed('edge', true).attr({
          d: function(d) {
            return "M0,0";
          }
        });
        g_edge.append('path');
        return g_edge.append('text').classed('mini-label', true);
      };

      View.prototype.exitEdges = function(exit) {
        return exit.remove();
      };

      View.prototype.updateEdges = function(graph) {
        var edges, i, radical, selector, trans, update, _i, _len, _ref,
          _this = this;

        edges = graph.edges;
        update = this.g_edges.selectAll("g.edge").data(edges);
        this.enterEdges(update.enter());
        this.exitEdges(update.exit());
        update.each(function(edge) {
          var cls, radical;

          radical = edge.line.data.radical;
          cls = "line_" + radical;
          return d3.select(this).classed(cls, true);
        });
        _ref = graph.radicals();
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          radical = _ref[i];
          selector = ".edge.line_" + radical.radical;
          d3.selectAll(selector).style({
            stroke: colors[i]
          });
        }
        update.each(function(edge) {
          if (edge.style.debug_stroke) {
            return d3.select(this).style({
              stroke: edge.style.debug_stroke
            });
          }
        });
        trans = update.transition().duration(config.transitionTime);
        trans.select('path').attr({
          d: function(edge) {
            return svgline01(edge.coords());
          }
        });
        trans.select('text.mini-label').attr({
          transform: function(edge, edge_i) {
            var a, angle, distance_to_central, grad, r, space_between, turn, width, x, y, _ref1;

            distance_to_central = edge.distanceToNode(graph.centralNode());
            if (distance_to_central % 5 !== 0) {
              return;
            }
            _ref1 = edge.tube, x = _ref1.x, y = _ref1.y, width = _ref1.width;
            a = angle = edge.firstAngleFromNode({
              x: x,
              y: y
            });
            r = utils.distance01.apply(utils, edge.coords().slice(0, 2));
            r /= 2;
            i = edge.tube.edges.indexOf(edge);
            i -= edge.tube.edges.length / 2 - 0.5;
            space_between = 16;
            x = x + r * Math.cos(angle);
            y = y + r * Math.sin(angle);
            x += (space_between * i) * Math.cos(angle);
            y += (space_between * i) * Math.sin(angle);
            turn = 0.5 * Math.PI;
            if (0.55 * Math.PI < Math.abs(a)) {
              turn = -turn;
            }
            a += turn;
            x += (width + 5) * Math.cos(a);
            y += (width + 5) * Math.sin(a);
            grad = angle / 2 / Math.PI * 360;
            grad = (Math.round(grad / 45)) % 2 === 0 ? 0 : -45;
            return "translate(" + x + " " + y + ")";
          }
        });
        return update.classed("filtered", function(edge) {
          return edge.style.filtered;
        }).select('text.mini-label').text(function(edge) {
          return edge.line.data.radical;
        }).style({
          fill: function(edge) {
            i = _this.graph.radicals().indexOf(edge.line.data);
            return colors[i];
          }
        });
      };

      View.prototype.updateStationLabels = function(graph) {
        return this.g_stationLabels.selectAll(".station-label").classed("filtered", function() {
          return this.style_filtered;
        });
      };

      View.prototype.update = function(graph) {
        var central_node, node, nodes;

        if (graph) {
          this.graph = graph;
        }
        this.updateNodes(this.graph);
        this.updateEdges(this.graph);
        this.updateStationLabels(this.graph);
        nodes = this.graph.nodes;
        central_node = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            node = nodes[_i];
            if (node.kind === 'central_node') {
              _results.push(node);
            }
          }
          return _results;
        })();
        if (central_node.length > 1) {
          throw 'cant handle more than one central node';
        }
        central_node = central_node[0];
        this.updateCentralNode(central_node);
        return d3.select('#toggle-bottom-bar').on('mouseenter.bottomBarToggle', this.toggleMenu);
      };

      View.prototype.createMiniLabel = function(edge, dom) {
        var color, grad, i, length, line, space_between, tube, x, x_mid, y, y_mid;

        dom = d3.select(dom);
        line = edge.line, tube = edge.tube;
        i = this.graph.radicals().indexOf(line.data);
        color = colors[i];
        space_between = 12;
        i = tube.edges.indexOf(edge) - tube.edges.length / 2;
        length = edge.length() / 2;
        x_mid = tube.x + length * Math.cos(tube.angle);
        y_mid = tube.y + length * Math.sin(tube.angle);
        x = x_mid + space_between * i * Math.cos(tube.angle);
        y = y_mid + space_between * i * Math.sin(tube.angle);
        x += (tube.width + 5) * Math.cos(tube.angle + 0.5 * Math.PI);
        y += (tube.width + 5) * Math.sin(tube.angle + 0.5 * Math.PI);
        grad = tube.angle / 2 / Math.PI * 360;
        grad = (Math.round(grad / 45)) % 2 === 0 ? 0 : -45;
        return dom.append("text").classed("mini-label", true).text(line.data.radical).style({
          fill: "" + color
        }).attr({
          transform: "translate(" + x + " " + y + ") rotate(" + grad + ", " + x + ", " + y + ")"
        });
      };

      View.prototype.updateCentralNode = function(node) {
        var central_freq, central_g, central_grade, central_history, central_kun, central_label, central_meaning, central_on, central_strokes, enter_central_node, exit_central_node, height, me, onClick, update_central_node;

        d3.select('#central-node').remove();
        update_central_node = this.svg.selectAll('#central-node').data([node]);
        enter_central_node = update_central_node.enter();
        exit_central_node = update_central_node.exit();
        central_label = node.label();
        central_meaning = node.data.meaning || "–";
        central_freq = node.data.freq || "–";
        central_strokes = node.data.stroke_n || "–";
        central_grade = node.data.grade || "–";
        central_on = node.data.onyomi || "–";
        central_kun = node.data.kunyomi || "–";
        central_history = this.history.render() || "–";
        central_g = enter_central_node.append('g').attr({
          'id': 'central-node'
        });
        central_g.append('foreignObject').attr({
          x: -120,
          y: -150
        }).attr({
          width: 230,
          height: 400
        }).append('xhtml:body').html("					 <div class='centralStation'>						<div class='firstBlock'>							<div id='kKanji'>" + central_label + "</div>							<table>								<tr>									<td>Strokecount</td>									<td id='kCount'>" + central_strokes + "</td>								</tr>								<tr>									<td>Frequency</td>									<td id='kFreqency'>" + central_freq + "</td>								</tr>								<tr>									<td>Schoolgrade</td>									<td id='kGrade'>" + central_grade + "</td>								</tr>							</table>						</div> 						<div class='secondBlock'>							<div id='kMeaning'>" + central_meaning + "</div>							<div id='kOn'>" + central_on + "</div>							<div id='kKun'>" + central_kun + "</div>							<div id='history'>							" + central_history + "							</div>						</div>					</div>					 ");
        exit_central_node.remove();
        height = (Math.round(this.history.history.length / 7) + 1) * 35;
        d3.select('#history').style('height', "" + height + "px");
        me = this;
        onClick = function() {
          var kanji;

          kanji = this.innerHTML;
          return me.changeToCentralFromStr(kanji);
        };
        return d3.selectAll("." + this.history.nclass).on('click.history', onClick);
      };

      return View;

    })();
    svgline = d3.svg.line().x(function(_arg8) {
      var x;

      x = _arg8.x;
      return x;
    }).y(function(_arg8) {
      var y;

      y = _arg8.y;
      return y;
    });
    svgline01 = d3.svg.line().x(function(d) {
      return d[0];
    }).y(function(d) {
      return d[1];
    });
    setFuncTimer = function(obj, ms, func) {
      return obj.funcTimer = setTimeout((function(d) {
        return func(d);
      }), ms);
    };
    clearFuncTimer = function(obj) {
      clearTimeout(obj.funcTimer);
      return obj.funcTimer = null;
    };
    delayDblClick = function(ms, func) {
      if (this.clickTimer) {
        clearTimeout(this.clickTimer);
        return this.clickTimer = null;
      } else {
        return this.clickTimer = setTimeout((function(d) {
          this.clickTimer = null;
          return func(d);
        }), ms);
      }
    };
    endnodeSelectLine = function(d) {
      var selector;

      selector = ".line_" + d.data.radical;
      d3.selectAll(selector).classed('highlighted', function(d) {
        return d.highlighted = !d3.select(this).classed('highlighted');
      });
      return d3.selectAll(".edge").sort(function(a, b) {
        return compareNumber(a.highlighted || 0, b.highlighted || 0);
      });
    };
    return {
      View: View
    };
  });

}).call(this);

/*
//@ sourceMappingURL=interactivity.map
*/
