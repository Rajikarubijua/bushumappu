// Generated by CoffeeScript 1.6.2
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  define(['utils'], function(utils) {
    var P, edgeCrossings, edgesUnderneath, lengthOfEdges, lineStraightness, segmentsOfNode, tooNearCentralNode, wrongEdgesUnderneath;

    P = utils.P;
    wrongEdgesUnderneath = function(node, edges) {
      var edge, wrong, _i, _len, _ref;

      wrong = [];
      _ref = edgesUnderneath(node, edges);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        if (__indexOf.call(node.edges, edge) < 0) {
          wrong.push(edge);
        }
      }
      return wrong;
    };
    edgeCrossings = function(edges_a, edges_b) {
      var a, b, crossings, _i, _j, _len, _len1;

      crossings = 0;
      for (_i = 0, _len = edges_a.length; _i < _len; _i++) {
        a = edges_a[_i];
        for (_j = 0, _len1 = edges_b.length; _j < _len1; _j++) {
          b = edges_b[_j];
          if (a.isCrossing(b)) {
            crossings++;
          }
        }
      }
      return crossings;
    };
    edgesUnderneath = function(node, edges) {
      var dists, edge, pair, underneath, _i, _len;

      underneath = [];
      for (_i = 0, _len = edges.length; _i < _len; _i++) {
        edge = edges[_i];
        dists = (function() {
          var _j, _len1, _ref, _results;

          _ref = utils.consecutivePairs(edge.coords());
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            pair = _ref[_j];
            _results.push(utils.distToSegment01.apply(utils, [[node.x, node.y]].concat(__slice.call(pair))));
          }
          return _results;
        })();
        if (config.gridSpacing * 0.9 > d3.min(dists)) {
          underneath.push(edge);
        }
      }
      return underneath;
    };
    lineStraightness = function(node) {
      var a, angle, angles, b, edges, value;

      angles = (function() {
        var _i, _len, _ref, _results;

        _ref = segmentsOfNode(node);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edges = _ref[_i];
          edges = utils.sortSomewhat(edges, function(a, b) {
            if (a.target === b.source) {
              return -1;
            }
            if (a.source === b.target) {
              return 1;
            }
          });
          a = edges[0];
          _results.push((function() {
            var _j, _len1, _ref1, _results1;

            _ref1 = edges.slice(1);
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              b = _ref1[_j];
              angle = a.getAngle(b);
              angle = Math.pow(angle, 2);
              if (angle < 0.00001) {
                _results1.push(0);
              } else {
                _results1.push(angle);
              }
            }
            return _results1;
          })());
        }
        return _results;
      })();
      return value = d3.sum(d3.merge(angles));
    };
    segmentsOfNode = function(node) {
      var edge, line, other, other_node, segment, segments, _i, _j, _len, _len1, _ref, _ref1;

      segments = {};
      _ref = node.lines;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        segments[line.id] = [];
      }
      _ref1 = node.edges;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        edge = _ref1[_j];
        other_node = node.otherNode(edge);
        other = edge.otherEdge(other_node.edges);
        segment = segments[edge.line.id];
        segment.push(edge);
        if (other) {
          segment.push(other);
        }
      }
      return d3.values(segments);
    };
    lengthOfEdges = function(edges) {
      var e;

      return d3.sum((function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = edges.length; _i < _len; _i++) {
          e = edges[_i];
          _results.push(e.lengthSqr());
        }
        return _results;
      })());
    };
    tooNearCentralNode = function(node) {
      var r;

      r = config.kanjiOffset * config.gridSpacing;
      return r > utils.distanceXY(node, {
        x: 0,
        y: 0
      });
    };
    return {
      wrongEdgesUnderneath: wrongEdgesUnderneath,
      lineStraightness: lineStraightness,
      lengthOfEdges: lengthOfEdges,
      edgeCrossings: edgeCrossings,
      tooNearCentralNode: tooNearCentralNode
    };
  });

}).call(this);

/*
//@ sourceMappingURL=criteria.map
*/
